<?php
/*************************************** (2018-3-12) 数据库索引的工作原理 + 工作中 Git 的规范 *****************************************************/
【索引的作用】
数据库中数据在磁盘上是以数据块的方式存在的
数据库会默认分配数据块 且指定数据块大小 比如是1024字节(1024kb = 1MB)

一个数据块会包含多条记录 

不加索引只能通过线性查找 | 加了可以通过二分查找 性能可能就不一样了 这就是索引的作用


【Mysql的并发控制与加锁分析】

	基本概念：
		快照读： 历史版本 读取回来不用加锁 所以可以直接写 不用 共享锁|拍他锁
		当前读： 读取之后要加锁
		幻读（不可重复读）：事务一先后执行共两次查询 事务二在这个过程中可能更改了数据
		脏读：

	mysql中并发控制基本是由隔离级别决定的且（级别越低并发效果越好）
		级别由高到低如下：
			可串行化：LBCC 就是在每一行加锁 利用 共享锁|排他锁
			...
			未提交读：可以读取没有提交的事务 会出现脏读

【索引的分类与理解】


【Git的规范使用】

	一般来说分为三层 由上而下 依次为 

		master

		feature1 feature2... hotfix temp ...

		dev

	1。日常的变更是针对feautre这一层的 拉到这一层的库 在这一层基础上创建dev分支 进行开发

	2.为什么在这一层还要创建分支？ 因为不创建分支的话feature主支有可能混乱 需要通过dev才能合并到 feature master

	3.然后测试检查 

	4.通过就将feature 合并到 master 分支 并推送到远程

	5.当然假如隔很长一段时间 master 才能修改 可以在master feature 中间再加一层 


/*************************************** (2018-3-7) The New Begins *****************************************************/
Sql 左右连接 根据什么字段连接
联合主键

/*************************************** (2018-3-6) The New Begins ****************************************************/
【工作 】
	1.优化代码
	2.软删除
	3.接口 重写给角色分配权限 + 表结构
	4.接口 返回角色所有权限
	5.接口 重写返回所有角色（查指定字段）
	6.接口 重写返回所有模块（查指定字段）
	7.接口 重写返回所有用户信息（查指定字段 + 自定义页码 + 自定义分配统计）

	todo：
		1.接口测试
		2.文档更新
		3.机柜下发

	* 今天使用了each 去改变 laravel paginate 里面的结果集

/*************************************** (2018-3-5) The New Begins *****************************************************/

【工作 】
	1.接口 给角色分配权限
	2.接口 给用户分配角色
	3.接口 用户登录返回角色|router
	4.接口 角色增删改查本地测试
	5.接口 模块的增删改查 （模块的编辑还要改）

	todos：
		1.权限管理接口测试
		2.物理删除->软删除
		3.机柜下发

	* 前后端分离的权限管理设计
		


/*************************************** (2018-3-4) The New Begins *****************************************************/
【工作 】
	1. 接口 返回所有模块信息
	2. 接口 返回所有用户信息+分配分组（带条件查询）
	3. 接口 科室查询（上层系统数据）
	4. 接口 返回所有角色信息
	5. 新增增添模块验证器
	   新增增添角色验证器
	   新增删除角色验证器
	6. 文档更新 
		用户：返回所有用户 | 科室查询
		角色：返回所有角色 | 创建角色 | 角色编辑 | 删除角色
		权限：返回所有模块
	7. 新增二级权限（二级权限结构的解析）

	todos：
		1.模块编辑
		2.删除模块
		3.角色分配
		4.模块分配
		5.角色接口测试	

	*今天好像试出来了 laravel paginate 页码只能使用默认的page参数



/*************************************** (2018-2-27) The New Begins *****************************************************/
【工作 权限管理】
	1. 方案设计 用户+角色模版+具体功能 （用户无须通过角色获取功能）
	2. 表设计 
	3. 接口 增添用户权限 （暂时已完成一级权限）
	4. 接口 登录返回用户权限（router）
	5. 权限验证中间件
	6. 公共方法 按父类排序所有权限组装router（一级权限）
	7. 接口 增添角色
	8. 接口 编辑角色
	9. 接口 删除角色
	10.新增 增添角色验证器
	11.新增 删除角色验证器

	todo：
		1.增添二级用户权限
		2.修改二级用户权限
		3.删除二级用户权限
		4.按角色模版分配权限| 按角色模版分配权限+用户权限配置
		5.表优化

		


	


/*************************************** (2018-2-27) The New Begins *****************************************************/
【工作 】
	1. workman 添写守护进程启动说明文档
	2. 权限管理设计（ Laravel-permission|Bouncer|RBAC+Gates）
	3. 同步前后端分页查询页码字段
	4. 修复 报修|打印综合查询 查询字段为空的情况 
	


/*************************************** (2018-2-27) The New Begins *****************************************************/
【	公共机配置信息 】：
	entner用户登录密码 ： entner...
	cabinet数据库密码 ： 123456
	root 用户密码 ： swtm@2019

【工作 接口调试】
	1. 用户修改密码接口调试
	2. 修复 返回所有打印信息接口 增加额外字段
	3. 修复 打印综合查询接口 闭包重写 + 分页
	4. 修复 报修接口 生成报修单号
	5. 修复 报修综合查询接口 闭包重写 + 分页
	6. 修复 报修驳回接口 请求方式
	7. 修复关于查询条件的验证规则

【划重点】
	laravel 中 条件数组的填充方式：
		= ： $condition['key'] = 'value'
		!=:  ['key','condition','value']

	闭包查询可以在查询之前做一些逻辑判断 而不是直接拿着查询条件就开始干，这样就给了更多的空间去匹配项目需求


/*************************************** (2018-2-24) The New Begins *****************************************************/
【一周总结】
	工作上：主要完成了多条件查询的编写工作 
			主要学习的点 
				1.是前后端的通信格式 我一开始的想法是错的
				2.时间开区间查询 而非一般的闭区间
	docker学习（根据自己的思维导图）
		...
	网络编程
		复习了几种通信模型
		*搞清楚了同步 /异步 阻塞/非阻塞的区别
		*select/poll 和 epoll的区别
		*文件描述符的概念 父子进程区分
		*区分了多进程|select IO复用 实现兵法网络编程的不同点
		...
	由此（网络编程 | Go）决定重新学习C语言 为深入网络编程（好多资料是用C写的）和Go|Python打下基础





/*************************************** (2018-2-22) The New Begins *****************************************************/
当镜像创建的有容器时是 不能删除镜像

今天上午把 docker 的基础过了一遍 还是很简单的 对于仓库 镜像 容器 数据卷 数据卷容器 网络端口映射 的概念有了基本的了解 
然而 偏偏没看 docker file 因为我打算用docker-compose 以为用不到 docker file 
【注意： docker-compose里面构建镜像 docker-file 用的也多】

在官网上又看了一下Mac 下的docker 使用 觉得不方便 所以又转到ubuntu上

【注意： ubuntu 默认没有安装 ssh 服务器】
【注意： sudo gpasswd -a ${USER} docker】执行docker 容器 需要将当前用户加入 docker 用户组 

/*************************************** (2018-2-21) The New Begins *****************************************************/



/*************************************** (2018-2-18) The New Begins *****************************************************/
【坑：】
	laravel get 用 count 判断是否获取成功

【docker】
	1.安装docker
	2.验证docker是否安装
	3.查看当前镜像 | 容器
	4.搜索镜像
	5.拉取镜像
	6.在镜像中运行容器 命令
	7.在容器中安装新的程序
	8.另存新的镜像
	9.运行新的镜像
	10.发布镜像


/*************************************** (2018-2-16) The New Begins *****************************************************/
【上周总结】：
	1.基本完成任务 没有什么拖欠
	2.关于常用的又看看了看
	3.给了自己一份任务清单 思维导图 
	4.新知识： vue | laravel 集合 | PHP 重载（面向对象） | Sql 主键/外键 | 调度任务 | mysql 远程登录
	*5. php 如何实现可用的依赖注入 | Git 操作 | 前端 json和后端数组的映射关系 | 

/*************************************** (2018-2-15) The New Begins *****************************************************/
【static 延迟静态绑定 https://www.cnblogs.com/codeAB/p/5560631.html】这个例子写的不错 

哈哈哈 廖雪峰又出SQL课程了 正可以看看：
	
	1.联合主键：对于联合主键，允许一列有重复，只要不是所有主键列都重复即可
	2.通过定义外键约束，关系数据库可以保证无法插入无效的数据。即如果classes表不存在id=99的记录，students表就无法插入class_id=99的记录。
	*3.由于外键约束会降低数据库的性能，大部分互联网应用程序为了追求速度，并不设置外键约束，而是仅靠应用程序自身来保证逻辑的正确性。这种情况下，class_id仅仅是一个普通的列，只是它起到了外键的作用而已。
	   这第三点讲的就很到位


【重点 Git 分支实战】
	先从本地
	远程有分支


	laravel 分页
	laravel 更新




/*************************************** (2018-2-14) The New Begins *****************************************************/
在 v-for 块中，我们拥有对父作用域属性的完全访问权限
v-for 也可以遍历对象的哈

 methods 中进行v-指令 事件处理



 今天由laravel 的调度任务 联想起了依赖注入
 	首先：依赖注入是怎么实现的 ？？ 当然是【反射】，那么反射又是怎么实现的呢？？ 又跑去看手册，把类反射、方法反射、反射抽象函数、方法参数、参数提示 ...
    看了一系列的东西 终于又把 PHP 的反射机制进一步的搞明白了。好 问题来了，提示类反射得到了，咋用？？ 当然需要实例化，实例化就又用到分发器，于是又跑去看【分发器】 
        ... 
    看分发器的时候又思考了一下为什么存在两个方法：
    	1. 实例化子类
    	2. 获取子类实例
    为什么不直接实例之后就直接返回呢？？ 认真再看一下 恍然大悟 一个进行实例操作（用的是延迟静态绑定）然后放入容器 ，返回的是整个容器啊！！！！
    而且返回就是通过【get_called_class()】这个方法，这个方法专门就是获取“后期静态绑定的”类名（这个联系尚且不必然）

    到这里 如何通过反射实现依赖注入（真正可以执行的）就明了了



/*************************************** (2018-2-13) The New Begins *****************************************************/
上午：
	1. 前端对接 给前端返回 json对象
	2. centos7 安装lmnp 
	3. centos7 用户密码管理
	4。mysql 远程登录 刷新权限
	5. 查询构建器 批量插入
	6. 调度任务



【laravel 集合】：
	集合由辅助函数 collect 生成 生成为Collectiong 实例 （注意 laravel 中很多值都是这个类型）
	接下来 在这种类型下 可以进行的常用的操作：
		all
		chunk 方法将一个集合分割成多个小尺寸的小集合
		collapse 方法将一个多维数组集合收缩成一个一维数组
		except 方法返回集合中除了指定键的所有集合项
		...




/*************************************** (2018-2-12) The New Begins *****************************************************/

自定义Git：
  1.忽略某些文件时，需要编写.gitignore；
  2..gitignore文件本身要放到版本库里，并且可以对.gitignore做版本管理！

  * 3.搭建 Git 服务器 
  		两个原因： Git收费 | 又不想开源
  		命令：git init --bare sample.git 建立一个裸仓库（没有工作区） 只用于版本管理
  		*学到一些额外需要注意的 ： 但我们建立裸仓库后 建议禁用shell登录（这一点没咋懂）
  				创建证书登录-收集用户公钥 | 


Mac 上利用virtualbox 搭建 lnmp
	1.oneinstack 是可以灵活卸载的 我直接把mysql卸载了 然后用官方的mysql。。。。 
		在这一步之前 还打算重新装一个虚拟机，但是网络又出问题了 懒得搞 
	2.可以用官方的mysql 居然还有获取随机生成密码的操作
		获取之后还必须重新修改密码 
		修改密码还。。
		总之 这种问题 根据报错提示 googles就行了



/*		*/

非空目录下创建Git版本库
Git 版本回退 中 --hard  的含义
Git 分支:
	1.Git 分支原理
	2.Git 创建 | 切换 | 合并（注意这里有一个领先分支、落后分支的说法 还有当前master分支 远程master分支的状态不统一的说法） | 删除分支
	3.一般来说是站着落后分支上合并领先分支
	4.合并分支的快进模式和手动解决冲突模式
	5.bug 分支 git stash 可以缓存工作区（比如当前有什么没有提交的 但是还不能够提交的）
	6.如果要丢弃一个没有被合并过的分支，可以通过git branch -D <name>强行删除。
	7.多人协作 
		如何针对分支做出一系列操作：
		创建分支并发布到远程
		远程已经有分支了 如何创建本地分支并关联
		如何clone | push 指定分支




/*************************************** (2018-1-31) The New Begins *****************************************************/
代码重构 ： 规范 | 优化逻辑 | 记录问题


/*************************************** (2018-1-30) The New Begins *****************************************************/
开会 进度安排
TAPD


/*************************************** (2018-1-29) The New Begins *****************************************************/
知识回顾：
	1.昨天从数据库中格式化时间戳的时候踩了一个坑 ： raw：db函数里面不能带引号 否则字段会失效
	2.POSTMAN 接口设置名称 |  改变顺序
	3.统计查询接口： 是要在格子表里面找柜子ID 即 cabinet_UID 而非 ID 
	4.从数据库中格式化时间 可以通过[时间戳] 通过方法 FROM_UNIXTIME 也可以通过[格式化时间字符串] 通过方法 DATE_FORMAT 
	5.php-fpm 进程池配置概念 更进一步的了解了php-fpm这个东西 和 nginx 通信的原理 
		其中值得注意的几点：
		a. 用户及用户组的设置 
		b. 监听地址

/*************************************** (2018-1-28) The New Begins *****************************************************/
知识回顾：
	1.关于数据库里面的时间字段有了更进一步的认识
		a.首先是用什么方式存储时间 有几种选择 datetime unixtime 我们认为 unixtime 更为合适 一个在性能上更好 二个在运算的时候更为方便
		b.在指定查找某种数据格式的时候 我们可以通过 FROM_UNIXTIME 去格式化我们想要的时间
	2.关于 laravel select db raw 有了进一步的认识
		db raw 里面其实就是填写字段 或者 函数 而且可以查找多个 反之 多个select则不行
		* db raw 里面的函数不能写引号 如 sum('price') 应该写为 sum(price)
 	3.


/*************************************** (2018-1-26、7) The New Begins *****************************************************/
上周总结：
	基本完成任务 更熟悉的掌握了前后端的开发模式

/*************************************** (2018-1-25) The New Begins *****************************************************/
数据迁移 + 模型工厂 + 填充器 

/*************************************** (2018-1-24) The New Begins *****************************************************/
1. 用 redis 改写 session 
	因为前端登录后，后端生成session并返回session_id,前端拿不到，所以直接采用redis 来存储用户登录后的身份信息
2.安装laravel 下的redis 扩展的时候也踩了一些坑
	首先是 predis 会和 php.ini已有的redis扩展冲突 需要在定义完整命名空间
3.composer 这个PHP依赖下载管理工具 以前都没怎么注意 今天去官网好好看了一下
  a.命令行下载 composer.phar 这是一个php执行程序
  b.可以直接移动到 环境变量下 全局使用
 *c.composer 实际使用的时候一般是这个思路
    首先当项目中没有composer.json文件的时候 我们需要编辑json 件然后执行composer install 去下载依赖
    当项目中存在json 文件之后 我们只需要 composer require 组件名 就可以自动下载依赖了 这个命令会下载依赖之后自动更新 composer.json文件
    最后当你没有使用 require 但存在json文件的时候 你可以选择编辑json 文件 然后执行 update 操作，但是注意 update 会更新json 文件里面的全部依赖 
    可能会导致版本不兼容的问题

4. 统计查询 
	Carbon运用
	Eloquent 模型里面使用 DB::raw 
5. 前后端分离部署 关键在于前端打包后的路径是直接映射在他的资源路径下的 （这一点当时卡的比较久）
6. modern php 
   过滤 ： 比如 Sql 条件，不过滤一些非法值会造成隐患，我以前还以为验证成功就够了，事实上不是这样，比如 一个条件是符合验证规则的，但是同样可能造成破坏
   验证
   转义

/*************************************** (2018-1-23) The New Begins *****************************************************/
1.repair 接口调整 搞懂一点 ： Validator验证器 接受的数据源实际上是一个一位数组 前端所传的数据格式为：
	{
		'a':'b',
		'c':'d',
	}
2.去除 repair 批量报修功能
3.json格式必须使用双引号
4.统计查询接口 ：
	a.移动端 ：柜子信息
	b.pc端：汇总
5.



/*************************************** (2018-1-22) The New Begins *****************************************************/

请假一天 玩了一下mac下面的lnmp 更清晰的了解了nginx与php-fpm的交互方式

玩了一下 mamp5 真机吧难用

/*************************************** (2018-1-21) The New Begins *****************************************************/

【BUG】 学会在postman中 复原前端的数据格式 就好在后端提取数据


可以看到，我们刚创建的数据库 runoob 并不在数据库的列表中， 要显示它，我们需要向 runoob 数据库插入一些数据。


/*************************************** (2018-1-20) The New Begins *****************************************************/

crontab 开机启动
crontab 日志处理




/*************************************** (2018-1-16) The New Begins *****************************************************/

回顾知识：
	laravel 全局函数 session的坑

	重点讲一下 git的运用（因为不喜欢在vim上编程 效率太低）所以选择把项目丢到git库里面

	首先 可以建立独立的服务器仓库 通过 git  不一定要用 github 服务器 


/*************************************** (2018-1-16) The New Begins *****************************************************/

昨天把项目移植到公共机上


/*************************************** (2018-1-15) The New Begins *****************************************************/

今天正式写接口
	接口主要有绑定 登录注册 | 统计查询 | 流水记录

	这里主要讲一下绑定接口的实现：
		分离验证类 | 延迟静态绑定统一数据回调接口 | firstOrCreate | 每一层都要Log | 监听器 缓存 
	整体而言代码分层比较舒服


	后期时间安排

	接口文档 注意返回实例可以自己在postman里面模拟

	【工作之余】

	shell 脚本 （到时候写监控日志） 
	f查看进程 找到进程id就行了
	$? 查看上次命令的退出状态
	用英文记忆 shell 分支
	shell 标准时间

	* crontab (centos7 上的设置真的简单 )
	  安装服务
	  编辑
	  运行
	  tail -f 动态查看真舒服
	  执行.sh 脚本 推荐添加 /bin/sh --> 权限

	* 脚本里面的服务重启 必须要指明根目录 比如 /etc/init.d/mysql restart


[明天 ：]
	还款
	解决 跨域 | token  => 保证前端能够正常访问 => 数据（逻辑）测试





/*************************************** (2018-1-14) The New Begins *****************************************************/

对上个周做个小结：
	任务划分为： 数据库设计 | 日志设计 | 接口开发 | 文档整理
	其中 数据库、日志设计	计划三天完成 实际情况也差不多 很多是搞懂了 在配置的时候踩了很多坑

	重点记录 数据库设计中的主从同步 | 日志设计 

		主从同步 - 账号、权限、change master
		(网上有很多主从同步的排错指南 也间接说明同步需要的步骤)

		日志设计 - shell脚本 （以 监控mysql服务为例 扩展到其他服务 写在启动脚本里 利用 crontab 循环检查）

明天 ：模拟数据 接口 跨域问题 		

/*************************************** (2018-1-10) The New Begins *****************************************************/

才明白过来 monolog 和 mongodb不是一个东西
简单了解了mongodb是啥子 亮点在于可以导出到Excel表里

ok ：
	1.准备一个 laravel5.4 的工程
	2.brew 安装 mongodb 【注意： brew update 指定版本 环境变量 指定目录夹】
	3.利用pecl 安装 php-mongodb 扩展 【注意： pecl 安装扩展会自动在php。ini文件中写入extension 当然也可以 find php.ini 手动设置】
	4.php.ini 更新之后一定要重启 php-fpm服务 有时候它是内嵌在web server中的，就需要重启web server 服务







mac 下启动nginx 记得 sudo nginx
mac 下服务 brew services 服务 命令


/*************************************** (2018-1-8) The New Begins *****************************************************/

回顾知识：
	1. laravel 错误&日志（调试模式 | 日志等级 | 配置|  规则）
	2. laravel artisan （知道了 console.php 是干嘛的了 其实就是 CLI的路由）
	3. laravel 事件 （了解观察者模式 | laravel如何生成事件、监听事件、触发事件）
		事件-监听 | 发布-订阅 ：

		在事件服务提供者里面注册事件和监听器，事件里面进行资源的初始化，监听器作具体逻辑，然后在控制器中使用Event门面方法触发事件即可，注意Event 门面里面一般要传入参数 - 构造函数
	4. laravel 开箱的websock 广播 大致看了一下 没有 workman 好用
	5. laravel 缓存大致看了一下 重点还是应该放在redis

	6. nginx 配置虚拟主机访问时 也需要设置防火墙

	7. TCP/IP 概述 对协议封装 协议栈 有了进一步的认识 （地铁上）

回顾任务：
	写一个独立的系统 具体参看我的时间轴 每日记录会照常记录




/*************************************** (2018-1-7) The New Begins *****************************************************/
nginx 配置文件再浏览一遍
注意一些新get的知识点： 
	1.nginx 解析php的两种通信方式 （nginx 与 php的工作原理之前已经了解过了）
	2.nginx 正则匹配 url 重写规则

* 尝试着写了一些laravel的依赖注入（在理解MVC的反射依赖注入的前提下）[特别是当调用一个静态方法的时候 在分发器中使用延迟静态绑定进行类的实例化和回掉]：
	还是挺简单的

	1.创建provider
	2.注册 配置文件
	3.在控制器中 引入文件 然后通过类型提示 实例化 

当然背后的原理当然是通过 自动加载 | 命名空间和目录的映射关系 | 反射 | 回调 		



/*************************************** (2018-1-3 ~ 4) The New Begins *****************************************************/
主要是解决项目迁移之后部署问题 涉及通讯、资源访问

通讯几个需要注意的地方：
	1.防火墙 设置白名单
	2.正确运行后台进程
	3.重复确认监听地址 （局域网内换路由经常跳ip）
	4.广播应监听本机网卡
	5.nginx 配置虚拟主机访问时 也需要设置防火墙




/*************************************** (2018-1-2) The New Begins *****************************************************/

回顾知识：
	1.梳理 smart 控制器
	  * 客户端发起连接时 45命令进行 cabinet_uid 绑定
	  * count 函数 第二个参数 递归计量
	  * mysql 8 strict false
	2.laravel 文件上传的两种方式
	3.mysql 并发控制 （共享锁 | 排他锁 | 当前读 | 快照读）





/*************************************** (2018-12-29) The New Begins *****************************************************/






/*************************************** (2018-12-28) The New Begins *****************************************************/


回顾知识：
	1 .git创建分支并发布到远程 把新建的本地分支push到远程服务器，远程分支与本地分支同名（当然可以随意起名）：

$ git push origin dbg_lichen_star:dbg_lichen_star
使用git branch -a查看所有分支，会看到remotes/origin/dbg_lichen_star这个远程分支，说明新建远程分支成功。


	2 .git clone 指定分支

	3.lnmp+redis 一键安装包 oneinstack  (这个包管理工具还可以在甄选)
	4.composer auto-dumpload的作用 ： composer.json 以来里面存在一个真正的composer库 这里面涉及自动加载 而自动加载的规则放在 auto-dumpload 执行：可以将该文件作为一个程序执行
	5.智能柜的命令 smartGrid 服务 

明天需完成：

	智能柜指令




/*************************************** (2018-12-27) The New Begins *****************************************************/

回顾知识：
	设置字体
	绑定UID的环节： OnMessage
	配置文件 主要是 setting smartcommand



/*************************************** (2018-12-26) The New Begins *****************************************************/

回顾知识：

	1.进一步摸清技术架构 、 工作流程 
	2.以“开柜子”指令为例读懂代码执行过程
	3.理解服务
		AES 加密
		Base 服务
			redis
			packageData
			curl 以及 接收 curl 传过来的数据 php:input
			文字转换为图片 -> 生成位图
			生成随机字符串

		ProcessData 服务
			JSON -> Array 双向转换
			XML  -> Array 双向转换


遗留问题：
	UDP广播
	字体设置


明天需完成：
	1. 服务
	2. 配置
	3. 控制器 智能柜相关命令



/*************************************** (2018-12-25) The New Begins *****************************************************/

回顾知识：

	1.网络实时通信的几种方式
	  	忙轮询
	  	长轮询
	  	websocket  APP 主动推送通知

	2.什么是长连接 、 短连接 、 长连接中的心跳

	3.实现网络通信的PHP框架 即实现以上几种通信的封装

		GatewayWork ： GateWay | Worker 进程组 | 目录结构中文件的作用 | 单向推送  | 属性设置 | 心跳
		Workman ： 进程池 fork 子进程 | 开发规范 | 

	4。question：
		GateWay 分配给 Worker 我能理解 但是 Worker 怎么又通过什么方式 转回GateWay？ 	

		

	


/*************************************** (2018-12-24) The New Begins *****************************************************/

告别了近乎三个月的空档 我又开始工作了。

回顾知识：
	1. Sql 优化 （粒度从小到大）

	  字段数据类型（在磁盘上占的内存大小）<数据字段索引<表引擎<表锁（今天才勉强搞懂 共享锁 S | 排他锁 X | 快照读（历史版本） | 当前读）< sql语句<读写分离<分表<分库

	2. Sql 日志
	  错误日志
	  通用
	  二进制日志
	  慢查询日志

    3. 项目技术架构 工作流程 主要讲了服务端中的服务模块 包括 token验证、加密、跨域请求、session共享、路径追踪


明天需完成：

	1.数据字典
	2.GatewayWork 
	3.Workman











/*************************************** (2018-11-2) Null *****************************************************/
郭颖请了一天假，陪她打了一天的游戏；她晚上心情不好


/*************************************** (2018-11-1) Git （今天的重点是分支管理）*****************************************************/

版本切换：
	HEAD 代表当前版本
	回退到上一个版本可以使用 git reset --hard HEAD^ 
	撤销对工作区的修改可以用 git checkout -- file
	但是当我们想从前一个版本到后一个版本肯定是不能回退的，只能找到对应的版本的commit id => git relog (记录每一条git命令)

工作区和暂存区：
	.git 这个隐藏目录里面东西超级多。主要包括了暂存区 + master分支

远程仓库：
	根据本地仓库同步远程仓库: git remote add origin git地址	

分支管理：
	为啥使用分支： 工作体验 => 你这边写好提交，其他人需要拉一下，反之自己也麻烦，如果不提交，线上得不到更新，如果不拉，内容不完整无法开发。

	创建并切换分支 ： git  checkout -b dev  == git branch dev + git checkout dev
	显示所有分支: git branch (其中前面有 * 号的代表当前分支)
 
	假设有一个master分支和一个dev分支 --
		我们在dev分支做了改变，master保持不变 合并分支的时候 利用快进模式（git merge）会很方便

		当时当我们分别对这两个分支都做了改变，要再合并的时候，就不能利用快进模式了，只能是手动解决冲突之后，重新提交，此时会产生一个新的节点，将之前的两个节点平滑过渡到同一个节点。

		*我们一般合并分支之后都会选择删除分支

		结论 ： master 分支不要去做内容修改只做同步操作 内容修改在分支上做，分支改好之后，合并到master就好了


[session|cookie] 当cookie被禁用之后，session该如何使用

1.URL 重写 也就是将 session id 放在url后面
2.隐藏表单提交 将session id 作为隐藏值





__FUNCTION__    函数名称（PHP 4.3.0 新加）。自 PHP 5 起本常量返回该函数被定义时的名字（区分大小写）。在 PHP 4 中该值总是小写字母的。
__CLASS__    类的名称（PHP 4.3.0 新加）。自 PHP 5 起本常量返回该类被定义时的名字（区分大小写）。在 PHP 4 中该值总是小写字母的。
__METHOD__    类的方法名（PHP 5.0.0 新加）。返回该方法被定义时的名字（区分大小写）。

注：这些常量前后均是两个下划线。

get_class(class name);//取得当前语句所在类的类名
get_class_methods(class name);//取得class name 类的所有的方法名，并且组成一个数组
get_class_vars(class name);//取得class name 类的所有的变亮名，并组成一个数组


/*************************************** (2018-10-21) PHP 面试特辑*****************************************************/
上午投简历 开始思考怎样选择公司 根据自己的喜爱进行匹配同时从自己喜好的公司里面获取所学技能点

PHP 基础：
  1.数据类型判断与强制转换
  2.php 运算符优先级 这些语言都是通用的
  3.利用缓存函数将页面静态化

设计模式：
  1.单例模式
  2.工厂模式 结合laravel核心概念 和反射

网络：
  常见的网络状态码含义 主要为3、4、5系列
  302 304
  401 403 404 405 
  500 503 502
  
常识：
  Mac菜单栏的常用技巧 已收藏文章至 tool

/*************************************** (2018-10-19)*****************************************************/
纪录片 - ILM（工业光魔）电影特效

/*************************************** (2018-10-18)*****************************************************/
l  302：重定向，当响应码为302时，表示服务器要求浏览器重新再发一个请求，服务器会发送一个响应头Location，它指定了新请求的URL地址；

l  304：当用户第一次请求index.html时，服务器会添加一个名为Last-Modified响应头，这个头说明了index.html的最后修改时间，浏览器会把index.html内容，以及最后响应时间缓存下来。当用户第二次请求index.html时，在请求中包含一个名为If-Modified-Since请求头，它的值就是第一次请求时服务器通过Last-Modified响应头发送给浏览器的值，即index.html最后的修改时间，If-Modified-Since请求头就是在告诉服务器，我这里浏览器缓存的index.html最后修改时间是这个，您看看现在的index.html最后修改时间是不是这个，如果还是，那么您就不用再响应这个index.html内容了，我会把缓存的内容直接显示出来。而服务器端会获取If-Modified-Since值，与index.html的当前最后修改时间比对，如果相同，服务器会发响应码304，表示index.html与浏览器上次缓存的相同，无需再次发送(节省传输成本)，浏览器可以显示自己的缓存页面，如果比对不同，那么说明index.html已经做了修改，服务器会响应200。

/*************************************** (2018-10-6)*****************************************************/
laravel 问答平台知识点简记

	自动验证
	读取私信的闭包写法

郭颖毕业设计项目需求：
  1.学号和手机号
  2.举报
  3.转发


 * git  多人合作 正确的使用方式
  
今天转了一下念头 原本打算把git的分支管理看完之后再想之前的问题的 但是想想工作中暂时还没有用到分支管理，于是专门查了一下常犯的错误即多人合并开发的解决办法，应该使用如下的步骤：
commit-pull-push
先把自己工作区的修改提交到暂存区，然后把远程的修改拉到工作区，对比冲突，有就手动合并，然后push。

/*************************************** (2018-10-5)*****************************************************/
看见laravel里面封装的函数 思考了一下 输入框是怎么获取上一次的输入值的 其实就是通过全局变量 

回顾一些git的知识点，但是我最想搞清楚的，也就是分支冲突还没有看，但是暂存区的撤销和工作区的回退的印象又加深了一步。


/*************************************** (2018-9-17)*****************************************************/
前后差不多花了2周左右的时间 搞了一套UI界面 其中用到了一款原型设计软件叫 Sk... 能够清晰的展现原型的样式，同时也对weex-ui组件有了基本的运用，其实像这些看文档就行了，不用特别注意，是一种非必须不重要的知识。


/*************************************** (2018-8-5)*****************************************************/

居然接近两个月没有写日志了 沉迷游戏 羁绊爱情

laravel 查询构建器一节 让我对 左右连接 有点顿悟的感觉 还有 悲观锁 乐观锁 都很不错




有位秀才第三次进京赶考，住在一个经常住的店里。考试前两天他做了三个梦，第一个梦是梦到自己在墙上种白菜，第二个梦是下雨天，他戴了斗笠还打伞，第三个梦是梦到跟心爱的表妹脱光了衣服躺在一起，但是背靠着背。这三个梦似乎有些深意，秀才第二天就赶紧去找算命的解梦。算命的一听，连拍大腿说：“你还是回家吧。你想想，高墙上种菜不是白费劲吗？戴斗笠打雨伞不是多此一举吗？跟表妹都脱光了躺在一张床上了，却背靠背，不是没戏吗？”秀才一听，心灰意冷，回店收拾包袱准备回家。店老板非常奇怪，问：“不是明天才考试吗，今天你怎么就回乡了？”秀才如此这般说了一番。店老板乐了：“哟，我也会解梦的。我倒觉得，你这次一定要留下来。你想想，墙上种菜不是高种吗？戴斗笠打伞不是说明你这次有备无患吗？跟你表妹脱光了背靠背躺在床上，不是说明你翻身的时候就要到了吗？”秀才一听，更有道理，于是精神振奋地参加考试，居然中了个探花


/*************************************** (2018-6-22)*****************************************************/
还是没有坚持 review 和 todos： ...

review:
这一周其实比较滑水。。。但是LNMP+PHPUnit+docker 这些知识点还是很有冲击的 然后就是答疑 这是一个再次学习的机会 我感觉我解决问题的能力或者说效率提高了,这是摩卡不知不觉中交给我的，感谢。

todos:
   3.PHPUnit的实验必须梳理的清清楚楚 因为要录视频 可以试着自己撸撸
   2.第三周挑战直播准备
   1.第三周文档优化
   4.实验楼文档整理 仓库整理
   5.实验楼文档备份


/*************************************** (2018-6-18)*****************************************************/

不知不觉已经过去这么久了嘛。。。

就在这周 摩卡走了  他跟我说了一些 我此时应该知道的也教会了我许多 我想我应该记住他

今天 
    1. 办的门禁卡 要带身份证和10元现金
    2. 中平老师的第一节课看完了  决定以后吃饭的时候都看他的课
    3. 《网络是怎样连接的》 第二章 （这一章内容真他妈多）

 
 todos： 
    1.我需要把之前的工作梳理一下 我需要继续留在这个公司直到我感觉 学习空间不大的时候   
    2.明晚有场电影 不是很想去 但是约好了 因为几十块伤害感情不划算


/*************************************** (2018-6-9)*****************************************************/
今天晴转阴 我上午看完房子 晚上就入住了
没想到冉峰也住这边

#逻辑英语#
1.课程的一些规则
2.公式（中英对照 | 颠倒）
3.偏正短语 
4.插入语
5.句子的主干查找 
  a. 主语怎么找  特殊主语的由来（there | it | 祈使句 | 愿望句）
  b. 谓语怎么找
  c. 宾语怎么找


/*************************************** (2018-6-8)*****************************************************/
今天主要工作是 楼+ PHP 第三周课程的视频添加 线上环境试验

主要学着去用几个vim命令 很有效的提高我的工作效率 ：

到文件末尾： shift + G
删除文件（从第一行到最后一行） ： 1,.d
寻找关键字： ／
下一个关键字： shift + n  = next
跳到指定行： number + (shift + G)


PHP 延迟静态绑定
call_user_func_array(function, param_arr) 这个函数实质上是模拟了函数重载 
类的反射问题 他为什么解决了依赖注入？

------以上都是学员提问之后，让我加深了进一步的认识


/*************************************** (2018-6-5)*****************************************************/
	todos:
		MVC 挑战的云文件休要修改 急！！！！！
		

/*************************************** (2018-6-4)*****************************************************/

  今天吃了大亏，实验楼的线上环境被我搞崩了，下次要记得保存，还好备份了文件到git，不过线上环境一变，还是会变，怎么办呢？
用 [scp] 可以基于ssh登录进行安全的文件拷贝|反向拷贝

  终于知道测试是干嘛了，就是写一些shell脚本检测文件、关键字、数据库、服务器

  todos：
  	1.checker
  	2.取书


/*************************************** (2018-6-2)*****************************************************/

自 2018-5-7 到 2018-6-2 一直在做公司的东西 时间比较紧凑 期间也学了不少东西 应该还是抽点时间多整理整理 以后还是要恢复 review | todos

review ： PDO 、 反射 、 修复视图bug 
todos  ：
		1. 在之前的基础之上，我需要在实验环境中再次过一遍MVC 记住保存实验环境 （现在留有一个模型bug）
		   而且尽量的我还要完成后面课程的实验实现  
		2. 我希望能找本书在下周之内看完


/*************************************** 面向对象 3(2018-5-7)*******************************************************/

PHP 的一些私有

抽象类的基本概念：	（见 2018-5-6）

PHP 异常处理： （见2017-8-4）

命名空间：
	-概述
		*注1： 命名空间不能仅仅为数字
		*注2:  编码问题（UTF8 without BOM）
		*注3:  必须在所有代码之前声明命名空间（declare 除外）


	-使用命名空间
	-命名空间（别名）
	-全局空间

/***************************************. PHP. （异常处理-error.php）错误控制(2017-8-4)*******************************************************/

<?php


/**
* TODO: error_reporting — 设置应该报告何种 PHP 错误
* int error_reporting([int $level])
* @param $level int 错误级别（强烈建议使用命名常量）
*/

#关闭所有错误
 error_reporting(0)
#显示一般性错误
 error_reporting(E_ERROR | E_WARNING | E_PARSE)
#显示notice
 error_reporting(E_ERROR | E_WARNING | E_PARSE |E_NOTICE)
#显示全部错误
 error_reporting(E_ALL)
#除了NOTICE全部显示
 error_reporting(E_ALL ^ E_NOTICE)


 #同时我们还可以通过数字来显示等级，例如：
 error_reporting(2047); #代表ALL


#是否展示错误信息到屏幕上
 display_errors()

#是否将脚本错误信息记录到服务器错误日志
 log_errors()


try{
	$x = 0;
	if($x == 0){
		throw new Exception('非法');
	}
}catch(Exception $e){
	echo "<pre>";
	echo $e->getMessage();
}


   
	

/*************************************** 面向对象 3(2018-5-6)*******************************************************/

/***************************************  面向对象 2(2017-11-1)  **************************************************/

Final 
	如果父类方法使用了关键字final，则该方法不可覆盖
	如果父类使用final 则该类不可继承

抽象类
	如果类中某一个方法使用abstuct声明，则该类必须声明为抽象类
	抽象类只声明方法名、形式，不具体实现 具有一般的所有访问控制属性

	*注1： 在任何一个类中，如果存在一个抽象方法，那么这个类必须被声明为抽象类
    *注2:  子类在继承抽象类的过程中，必须继承父类的所有抽象方法
    *注3:  在继承抽象类的过程中，子类的调用方式必须与父类一致
    *注4:  抽象类一样可以定义公有方法



对象接口
	iterface 声明接口
	接口中定义的所有方法必须是公有的
	实现接口的类 必须实现所有方法，否则会报错

【关于抽象类和对象接口的一般区别、应用场景】

trait
	trait 声明trait
	可以理解为独立的扩展类
	利用use引入

参看为什么使用trait？	

匿名类
	我的理解：类的闭包形式，形式如下：
	$aysnc = new Class{
		public xxx
	}


遍历对象	foreach 
	只有可见属性才能被遍历

对象复制（没懂）
	$CloneObject = clone $OriginObject
	clone 关键字只会执行一个浅复制
	__clone() 会建立一个对象副本

对象比较
	所有属性 及其 属性值都相等 且 所属同一个实例




/*------------Round II  面向对象 1--------------	2017-6-11 更*/

一、定义
	对象与数组都是复合类型（一个变量可以存储多个元素）而对象还能够存储函数，
且具有封装、继承、多态（PHP里面好像没有哦）的特点，功能十分强大。

	1.类、对象
	 类是一类东西的结构描述，而对象则是一类东西的一个具体实例。
	 声明类->创建对象->调用对象
	 类中的变量与函数为成员属性（成员变量）、成员方法。
	 
	2.命名原则
	 一个文件只允许包含一个类（这个说法是❌的 2017-6-11）
	 文件名：类名.class.php
	 类名  ：AaaBbbCcc  首字母大写(大驼峰)
	 函数名：aaaBbbCcc  小驼峰
	 常量  ：AAABBBCCC  全大写
 
 二、声明类以及实例化对象
 	Class
 	New 	

 

 三、对象与实例之间关系
 【每实例化一个对象就在内存中分配一个空间
 		实例化的对象放在堆内存中 并附带一个（内存地址） 这样就可以通过 对象变量（放在栈区）去访问对象
 		参看object_base.php 例1
 	】


 四、对象继承
 	Extends
 	*PHP 不支持多继承（一个类只能继承基类）但是可以通过trait特性模拟
 	*覆盖 ： 继承的父类可能被子类使用（同样的）方法和属性名覆盖，此时可以使用final

 五、PHP面向对象新特性
 	*通过变量名来实例化对象
 	*::class 解析类的完全限定名称
 	*trait 模拟多继承	

 六、类常量


 七、Static（静态关键字）
 	static   用于定义静态变量 | 后期静态绑定
 			 声明静态方法或者静态属性 （这两者都可以不实例化类而直接访问）
 		  *注：静态属性不能通过实例化对象访问 但静态方法可以 





 八、范围解析操作符



 九、构造函数与析构函数

 十、对象继承

 十一、对象接口（用处何在？）










/*************************************** 实验楼 Lou18 (2018-5-4)*******************************************************/
PHP or 三元操作符

12. __callStatic()
14.
15.
16. 
22. 

/*************************************** 实验楼 Linux (2018-5-4)*******************************************************/
区段	说明
1	一般命令
2	系统调用
3	库函数，涵盖了C标准函数库
4	特殊文件（通常是/dev中的设备）和驱动程序
5	文件格式和约定
6	游戏和屏保
7	杂项
8	系统管理命令和守护进程



who 查看当前用户相关信息
 -a 打印全部
 -q 打印当前用户数及用户名
 -u 打印当前用户登录信息


【文件权限】
	文件或目录的访问权限分为三类：读、写、执行

	讲讲分别代表了什么意思：
		读：可以读取内容，但禁止修改
		写：
		执行：可以将该文件作为一个程序执行
	
	常用相关命令：
		chmod 【选项】【mode】【file】【控制文件或目录的权限】
			-c 文件发生改变时，报告处理信息
			-R 递归处理子文件

			设置权限：
				1.数字方式 【数字与字符关系对应如下 r-4 w-2 x-1】
				chmod  775 file 
				2.字符方式 【掌握权限群体字符表示 u g o a】
				chmod u+r,go+w file 	可以看书这种方式更适合一次更替一个权限列表

		chgrp  [选项]【组】【file】【更改文件或目录所属组】

			-v 运行时显示详细信息
			-R 递归处理
			-reference 指定参考文件或目录

			例：
				chgrp -v bin log2012.log 	将文件。log所属群组改为bin

		chown 【选项】【所有者】：【组】【file】【更改文件所有者或群组】
			例：
				chown -v mail:mail log


【用户权限】

	Linux中权限有分三个分组：所有者、同组用户、其他用户

	groups ：查看自己属于哪个用户组
	/etc/group : 查看用户组信息

	groupadd： 创建新的用户组

	groupmod:  修改用户组相关信息


    adduser : 创建新用户
    deluser ：删除用户

    *usermod 【选项】【用户账号】 【修改用户账号信息】
       -e 	 修改账号的有限期限 
       -g    修改账号的所属群组
       -u。  修改用户ID
       -U。  解除密码锁定  
      *-G    将用户组追加到用户账户的用户组列表末尾 （就是给用户一个新的用户组）



【环境变量】
	Shell环境下，常见的三种变量类型：
		1.用户自定义变量
		2.内置变量
		3.自定义导出的的环境变量

	命 令	    说 明
	set	       显示当前 Shell 所有变量，包括其内建环境变量（与 Shell 外观等相关），用户自定义变量及导出的环境变量。
	env	       显示与当前用户相关的环境变量，还可以让命令在指定环境中运行。
	*export	   显示从 Shell 中导出成环境变量的变量，也能通过它将自定义变量导出为环境变量。
	（注意：export可以将自定义变量导出为环境变量 | 但是生存周期比较短）


	添加自定义路径到环境变量：

		PATH=$PATH:/home/shiyanlou/mybincat  (注意：这种方式也只能在当前环境生效 重启之后会失效)

		解决办法是： echo "PATH=$PATH:/home/shiyanlou/mybin" >> .zshrc （追加而不是覆盖到zshrc配置文件）
				


/***************************************  Linux command line【第七章：重定向】(2017-11-18)  **************************************************/
Linux 重定向：

【标准输入 | 标准输出】

	Unix哲学 任何东西都是文件 设备也是（以下的键盘和屏幕都是文件）
	标准输入：	程序从一个叫做标准输入（stdin）的设备（文件）中得到输入，默认情况下连接到键盘		  【文件描述符 0】

	标准输出：	程序运行的结果输送到一个叫做标准输出的文件（stdout）							  【文件描述符 1】	
	标准错误：	程序运行的状态信息输送到一个叫做标准错误的文件（stderr） 默认情况 以上两者连接到屏幕 【文件描述符 2】

输出自然引出了【重定向】的问题，因为有的时候我们不想使用缺省值，而更想将屏幕上的数据转移到文件进行持久化

如果我们重定向错误，例如：
	[me@linuxbox ~]$ ls -l /bin/usr > ls-output.txt
	ls: cannot access /bin/usr: No such file or directory

	为什么这条错误信息依然在屏幕上而非重定向的地方？
	因为我们重定向的是标准输出不是标准错误....

	那么，如何重定向错误呢？
	答：	ls -l /bin/usr 2> ls-output.txt 	【2是标准错误在shell的描述符】

	联合重定向（同时重定向标准输出和标准错误到文件）：
		ls -l /bin/usr > ls-output.txt   2>&1
		* 重定向标准输出的位置总是要放在标准错误前面
		

	又如何隐瞒错误？【项目上线运行的时候，我们必须保持足够沉默】
	答：通过重定向输出结果到一个叫做”/dev/null”的特殊文件

	【标准输入】  

		cat【参见 文件操作】 通过输入cat接受标准输入
		cat < file 将标准输入（键盘）重定向到文件

		| ： 管道线	【从标准输入中读取数据然后输送到标准输出的功能被称为管道】
		**	管道线逆而行之： 将一个从标准输出通过管道传输至标准输入，这极为重要也极为常用 我们通常会用ls来获取多个标准输出 然后统一到标准输入进行过滤查询
			例如：
				我们想把目录/bin 和/usr/bin 中 的可执行程序都联合在一起，再把它们排序，然后浏览执行结果： 
					[me@linuxbox ~]$ ls /bin /usr/bin | sort | less  #管道线后面的都是默认接受标准输入
			添加wc到管道线统计程序行列数是一种很有效的方式
			例如：		
				[me@linuxbox ~]$ ls /bin /usr/bin | sort | uniq | wc -l
			output：2728
		tee  从标准输入读取数据，同时写到标准输出和文件









/*************************************** 实验楼 PHP 楼赛 (2018-5-3)*******************************************************/
xss

框架有哪些模式？

ORM

/*************************************** 软件概念了解 (2018-4-30)*******************************************************/
虚拟机
iterm
zsh
Oh my zsh


/*************************************** PHP 《剑指 offer》 String(2018-4-29)*******************************************************/

/*************************************** PHP 《剑指 offer》 List(2018-4-28)*******************************************************/



/*************************************** 数据库基本设计(2018-4-26)*******************************************************/
数据库设计基本步骤：
	1.需求分析（数据有哪些？数据特点（时效性）？用什么类型包装比较合适？）
	2.逻辑设计（数据与数据之间的关系（实体））
	3.物理设计（分表 分库 数据库引擎 字段类型）
	4.维护优化（索引、拆分）

数据库术语：
	关系：表
	元组：表中的一行
	属性：表中的一列
	候选码：几个属性组成的组，也具有唯一标识作用，标识某行
	主码：具有唯一标识作用的某个属性或者某组属性
	域： 属性的取值范围
	分量：元组中的一个属性值


数据库操作异常：
	1.插入异常：某个实体随着另一个实体的存在和销毁而随之存在和销毁
	2.更新异常：更改表中某个属性，需要将表中多行数据更新
	3.删除异常：删除表中某行数据导致另一个实体数据丢失	

数据库范式：
	1NF：数据库中所有字段都是不可再分的单一属性（即二维表）
    2NF：组合关键字（候选码）中任意一个字段都可以决定表中某些属性的值（本应该由候选码组合决定）
    3NF：不存在非关键字段对候选码具有传递函数依赖


/***************************************. PHP. String(2017-8-23更)*******************************************************/
	htmlentities(string)	#将所有字符串转换为HTML实体 == htmlspecialchars
							 对应的逆向操作

	str_pad(input, pad_length)		#填充字符串
	str_repeat(input, multiplier)				 	




/***************************************. PHP. String(2017-8-19更)*******************************************************/
	/**
	 * delimiter 分隔符
	 * string 	 原字符串
	 * return 	 数组
	 */  

	explode(delimiter, string) #顺序不能改变
	join = implode(glue, pieces)	

	str_split(string)
	strip_tags(str)	#去除HTML 标记

	stripos(haystack, needle) #查找字符串首次出现的位置
	strpos(haystack, needle)

	strrpos(haystack, needle) #查找字符串在目标字符串中最后一次出现的位置
	strripos(haystack, needle)

	strrchr(haystack, needle)	#查找指定字符在字符串中最后一次出现的位置

	*strrev(string) 	#反转字符串

	strtoupper(string)	#转换字符串为大写
	strtolower(str)		#转换字符串为小写
	ucfirst(str)	#将字符串的(首字母)转换为大写
	ucwords(str)	#将字符串中单词的首字母转换为大写



/***************************************. PHP. String(2017-8-2)*******************************************************/

存取和修改字符串中的字符
String 可以用类似array结构来访问和修改
	str_replace(search, replace, subject)	#子字符串替换，返回替换后的数组或者字符串
	str_ireplace(search, replace, subject)	#同上 不区分大小写

	substr(string, start, length)			#返回字符串的字串
	substr_replace(string, replacement, start,length)	#在上面的基础上添加了一个待替换的字符串,返回替换后的字符串
	substr_count(haystack, needle)	#计算字串出现的次数

	*注意区分substr_replace 和 str_replace的区别

	*parse_url(url,component)	
	*parse_str(str,array)	#将复杂的字符串解析成多个变量，有时候用explode不方便比如：$str = "first=value&arr[]=foo+bar&arr[]=baz";

	strpos(haystack, needle,[offset])	#查找字符串首次出现的位置
	stripos(haystack, needle,[offset])			#与上面类似，不区分大小写
	strrpos(haystack, needle,[offset])	#查找字符串最后一次出现的位置
	strripos(haystack, needle,[offset])			#与上面类似，不区分大小写


	trim(str)
	strlen(string)


	strip_tags(str,allow_tags)	#过滤掉字符串中HTML 和 PHP标记 并返回
	/**
	htmlspecialchars(string)	#将特殊字符转换为HTML实体同htmlentities（相当于转义了） 
	& (& 符号)	&amp;
	" (双引号)	&quot;，除非设置了 ENT_NOQUOTES
	' (单引号)	设置了 ENT_QUOTES 后， &#039; (如果是 ENT_HTML401) ，或者 &apos; (如果是 ENT_XML1、 ENT_XHTML 或 ENT_HTML5)。
	< (小于)	&lt;
	> (大于)	&gt;
	*/

/***************************************  面试备战-PHP基础(2018-4-20)  **************************************************/
1.时间函数扩展
  设置默认时区： 
  date

2.获取文件扩展名的多种方式 | 目录文件的遍历 | 文件路径（参见 Manaul／filesystem.php）

3.会话控制（cookie | session）

4.PHP模板引擎 | MVC 

5.PHP字符串处理（转义 截取）

  htmlspecialchars(string)
  htmlspecialchars_decode(string)

  substr(string, start)
  substr_replace(string, replacement, start)

6.PHP URL处理（编码 截取 加密 解密）

	base64_decode — 对使用 MIME base64 编码的数据进行解码
	base64_encode — 使用 MIME base64 对数据进行编码
	get_headers — 取得服务器响应一个 HTTP 请求所发送的所有标头
	get_meta_tags — 从一个文件中提取所有的 meta 标签 content 属性，返回一个数组
	http_build_query — 生成 URL-encode 之后的请求字符串
	parse_url — 解析 URL，返回其组成部分
	rawurldecode — 对已编码的 URL 字符串进行解码
	rawurlencode — 按照 RFC 3986 对 URL 进行编码
	urldecode — 解码已编码的 URL 字符串
	urlencode — 编码 URL 字符串

	*注意区分 urlencode 和 rawurlencode ：
	   唯一的不同是对空格的处理，urlencode处理成“+”，rawurlencode处理成“%20”

7.PHP发送HTTP请求的几种方式 
	a.socket
	b.curl
	c.file_get_contents

8.PHP新特性和废弃的特性 
  废弃：	


前端基础知识（HTML、CSS、JS）	表单：
		- 文本框input-text；密码框
		- 下拉框select-option
		- 文本域textarea
		- 单选 input-radio
		- 多选 input-checkbox
		- 按钮 input-button、submit、reset；图片按钮
		- form提交方法：get post
		- 触发动作：onclick、onblur、onfocus、onchange
		- 表单验证


PHP基础知识-常用函数：
		字符串：
			- 单引号与双引号（变量嵌入）
			- 字符串连接
			- 去除空格trim()
			- 替换：str_replace()
			- 位置：strpos()
			- 长度：strlen(), mb_strlen()
			- 大小写：strtoupper()，strtolower()
			- 截取：substr, strstr
			- 字符串与数组转换：implode、explode
			- 去除标签strip_tags

		数组：
			- 数组打印
			- 数组下标（支持字符串；默认从0开始；）
			- 数组增减元素array_shift()、array_pop()、array_push()
			- 数组输出foreach
			- 数组排序sort()、rsort()、asort()、ksort()
			- 数组长度count()、array_count_values()
			- 序列数组range()
			- 是否数组is_array()
			- 多维数组
			- 正则表达式

		时间日期：
			- 时间戳的概念
			- 日期格式化date("Y-m-d H:i:s")
			- 当前时间戳time()
			- 客户端时间和服务器时间

		类：


		Cookie和Session：


		异常处理：
			error_reporting(0)
			display_errors


		其他：
			set_time_limit(0)
			urlencode
			json_encode

PHP基础知识-语法：
	- PHP的注释
	- 类型转换：intval()
	- 表达式?:
	- 区分=、==与=== 及!=
	- True与false的等价条件
	- 变量名称的合法性
	- 变量的变量$$a
	- 变量的isset()和empty()
	- 逻辑判断||、&&
	- 运算符$a++ 与 ++$a
	- 运算符+= 与 .=
	- 运算符%
	- 预定义变量$_POST、$_GET、$_COOKIE、$_SESSION、$_REQUEST
	- 预定义常量__FILE__ 、TRUE、 FALSE、 NULL
	
	条件语句与循环语句：
		- for
		- if-else
		- switch
		- while
		函数基础：

		- 打印函数：echo、print_r()、var_dump()
		- 终止函数：exit()、die();
		- 包含文件：include()、require()、require_once()及其区别
		- 变量作用域：$global
		- 变量引用：&$a


数据库（主要MySQL）基础知识：
	Mysql的安装与使用（my.cnf）
		- 3306端口
		- 最高级用户root
		- 创建数据库和删除数据库create database xxx;drop database xxx;
		- 创建表和删除表create table xxx;drop table xxx;
		- 清空表
		- 导入SQL：source命令
		- MySQL的数据类型
		- 字段：主键、索引、Auto_Increment
		- 增、删、改
		- 排序order by, asc desc
		- limit
		- 多表查询
		- phpmyadmin
	服务器相关知识（操作系统、软件、网络端口等）
		Apache的安装（httpd.conf）
		- 80端口
		- DocumentRoot
		- DerectoryIndex
		- Options Indexes
		- AllowOverride (.htaccess)	
	

/***************************************  ECMA6(2017-1-16)  **************************************************/
一、新增命令
	1.let 
		-声明块级作用域变量 
		-阻止变量提升
		-暂时性死区 | 封闭作用域 
		-不允许在相同作用域中声明同一个变量

	*ES6明确规定可以在块级作用域中声明函数，但函数行为在外部不能获得

	2.do表达式
		-块级作用域通常是用来临时使用，没有返回值，解决此种情况的方法是通过将块级作用域转化为do 表达式 例如：
		```
		let x = do {
		  let t = f();
		  t * t + 1;
		};
		·上面代码中，变量x会得到整个块级作用域的返回值（t * t + 1）。
		```
	3.const声明一个只读的常量。一旦声明，常量的值就不能改变
		-旨在块级作用域内有效

	4.impirt

	5.class

	*顶层对象的属性与全局变量
		在ES5中，全局变量即为顶层对象的自然属性
		在ES6中，通过let、class、const声明的全局变量不隶属于任何自然属性
/***************************************  ECMA6（2017-3-19)  **************************************************/
1.let与const
	let：
		a.块级作用域
		b.暂时性死区（变量申明之前什么都无法使用）（所以不存在变量提升）
		c.不允许重复声明同一个变量
		d.ES6 引入了块级作用域，明确允许在块级作用域之中声明函数
	const：(几种特性同let)
		
	common：	let、const、class声明的全局变量不属于顶层对象的属性


/***************************************  Node.js-模块（2017-3-19)  **************************************************/
*一个js文件就是一个模块，去掉.js后缀为模块名
*引用一个模块 使用require +  路径 + 模块名

1.基本模块
	global
	process

2.文件模块	
3.http模块
/***************************************  JS重现-CORS（2017-3-18)  **************************************************/

/***************************************  JS重现-操作DOM（2017-3-18)  **************************************************/


/***************************************  JS重现-Promise（2017-3-17)（重点）  **************************************************/

/***************************************  JS重现-面向对象编程（2017-3-17)  **************************************************/
JavaScript不区分类和实例的概念，而是通过原型（prototype）来实现面向对象编程。

操作原型：
	1.在编写JavaScript代码时，不要直接用obj.__proto__去改变一个对象的原型
	2.Object.create()方法可以传入一个原型对象，并创建一个基于该原型的新对象，（注：但是新对象什么属性都没有，只有原型的属性）
	3.当我们用obj.xxx访问一个对象的属性时，JavaScript引擎先在当前对象上查找该属性，如果没有找到，就到其原型对象上找，如果还没有找到，就一直上溯到Object.prototype对象，最后，如果还没有找到，就只能返回undefined。
	*4.第二条是创建原型对象的方法之一 ，下面介绍另一种方法（构造函数）：
		new function 
		现在理一下对象、原型、原型对象、原型对象方法

		function Student(props) {
		    this.name = props.name || 'Unnamed';
		}

		Student.prototype.hello = function () {
		    alert('Hello, ' + this.name + '!');
		}

		student为构造函数，也为以此为构造函数的对象的原型（重点），而student.prototype为原型对象，Student.prototype.hello为原型对象的方法

/***************************************  JS重现-标准对象（2017-3-16)  **************************************************/

/***************************************  JS重现-高阶函数（2017-3-15)  **************************************************/


/***************************************  JS重现-函数方法（2017-3-14)  **************************************************/
绑定到对象上的函数称为方法，和普通函数也没啥区别，但是它在内部使用了一个this关键字，这个东东是什么？

function getAge() {
    var y = new Date().getFullYear();
    return y - this.birth;
}

var xiaoming = {
    name: '小明',
    birth: 1990,
    age: getAge
};

xiaoming.age(); // 25, 正常结果
getAge(); // NaN

JavaScript的函数内部如果调用了this，那么这个this到底指向谁？

如果以对象的方法形式调用，比如xiaoming.age()，该函数的this指向被调用的对象，也就是xiaoming，这是符合我们预期的。

如果单独调用函数，比如getAge()，此时，该函数的this指向全局对象，也就是window。



/***************************************  JS重现-变量作用域与解构赋值（2017-3-14)  **************************************************/



/***************************************  JS重现-Map、Set、iterable（2017-3-14)  **************************************************/
JavaScript的默认对象表示方式{}可以视为其他语言中的Map或Dictionary的数据结构，即一组键值对。

但是JavaScript的对象有个小问题，就是键必须是字符串。但实际上Number或者其他数据类型作为键也是非常合理的。

为了解决这个问题，最新的ES6规范引入了新的数据类型Map。


Map

	Map是一组键值对的结构，具有极快的查找速度。

	举个例子，假设要根据同学的名字查找对应的成绩，如果用Array实现，需要两个Array：

	var names = ['Michael', 'Bob', 'Tracy'];
	var scores = [95, 75, 85];
	给定一个名字，要查找对应的成绩，就先要在names中找到对应的位置，再从scores取出对应的成绩，Array越长，耗时越长。

	如果用Map实现，只需要一个“名字”-“成绩”的对照表，直接根据名字查找成绩，无论这个表有多大，查找速度都不会变慢。用JavaScript写一个Map如下：

	var m = new Map([['Michael', 95], ['Bob', 75], ['Tracy', 85]]);
	m.get('Michael'); // 95
	初始化Map需要一个二维数组，或者直接初始化一个空Map。Map具有以下方法：

	var m = new Map(); // 空Map
	m.set('Adam', 67); // 添加新的key-value
	m.set('Bob', 59);
	m.has('Adam'); // 是否存在key 'Adam': true
	m.get('Adam'); // 67
	m.delete('Adam'); // 删除key 'Adam'
	m.get('Adam'); // undefined
	由于一个key只能对应一个value，所以，多次对一个key放入value，后面的值会把前面的值冲掉：

	var m = new Map();
	m.set('Adam', 67);
	m.set('Adam', 88);
	m.get('Adam'); // 88

/***************************************  JS重现-对象(2017-3-14)  **************************************************/

JavaScript用一个{...}表示一个对象，键值对以xxx: xxx形式申明，用,隔开。（注意，最后一个键值对不需要在末尾加,，如果加了，有的浏览器（如低版本的IE）将报错）。
*所有对象的键都为字符串
要检测一个对象是否拥有某一属性，可以用in操作符：
	var xiaoming = {
    name: '小明',
    birth: 1990,
    school: 'No.1 Middle School',
    height: 1.70,
    weight: 65,
    score: null
	};
	'name' in xiaoming; // true
	'grade' in xiaoming; // false

不过要小心，如果in判断一个属性存在，这个属性不一定是xiaoming的，它可能是xiaoming继承得到的：

'toString' in xiaoming; // true
因为toString定义在object对象中，而所有对象最终都会在原型链上指向object，所以xiaoming也拥有toString属性。

要判断一个属性是否是xiaoming自身拥有的，而不是继承得到的，可以用hasOwnProperty()方法：

var xiaoming = {
    name: '小明'
};
xiaoming.hasOwnProperty('name'); // true
xiaoming.hasOwnProperty('toString'); // false


** for ... in 是for循环的变体，它专门针对JS对象，遍历对象属性


/***************************************  JS重现-String(2017-3-13)  **************************************************/
1.反引号`...`表示多行字符串 （ES6）
2.字符串连接用‘+’号
*字符串是严格区分大小写的
3.如果有很多变量需要连接，用+号就比较麻烦。ES6新增了一种模板字符串（ES6）：
	var name = '小明';
	var age = 20;
	var message = `你好, ${name}, 你今年${age}岁了!`;
	alert(message);

4.JS中字符串实质上是对象
	s.length; // 13
	indexOf
	substring
	ToLowerCase
	split

/***************************************  JS重现-数组(2017-3-13)  **************************************************/
1.直接给Array的length赋一个新的值会导致Array大小的变化：
2.对Array的索引进行赋值会直接修改这个Array
3.Array对象的相关操作
  a.indexOf
  b.slice = substring(string 版)

  var arr = ['A', 'B', 'C', 'D', 'E', 'F', 'G'];
  arr.slice(0, 3); // 从索引0开始，到索引3结束，但不包括索引3: ['A', 'B', 'C']
  arr.slice(3); // 从索引3开始到结束: ['D', 'E', 'F', 'G']

    *splice  向数组增加或删除元素

  c.push和pop

	push()向Array的末尾添加若干元素，pop()则把Array的最后一个元素删除掉：

	var arr = [1, 2];
	arr.push('A', 'B'); // 返回Array新的长度: 4
	arr; // [1, 2, 'A', 'B']
	arr.pop(); // pop()返回'B'
	arr; // [1, 2, 'A']
	arr.pop(); arr.pop(); arr.pop(); // 连续pop 3次
	arr; // []
	arr.pop(); // 空数组继续pop不会报错，而是返回undefined
	arr; // []
 
  d.unshift和shift

	如果要往Array的头部添加若干元素，使用unshift()方法，shift()方法则把Array的第一个元素删掉：

	var arr = [1, 2];
	arr.unshift('A', 'B'); // 返回Array新的长度: 4
	arr; // ['A', 'B', 1, 2]
	arr.shift(); // 'A'
	arr; // ['B', 1, 2]
	arr.shift(); arr.shift(); arr.shift(); // 连续shift 3次
	arr; // []
	arr.shift(); // 空数组继续shift不会报错，而是返回undefined
	arr; // []	

  e.sort

	sort()可以对当前Array进行排序，它会直接修改当前Array的元素位置，直接调用时，按照默认顺序排序：

	var arr = ['B', 'C', 'A'];
	arr.sort();
	arr; // ['A', 'B', 'C']	

  f.reverse (字符串反序算法 使用栈即可解决)

	reverse()把整个Array的元素给掉个个，也就是反转：

	var arr = ['one', 'two', 'three'];
	arr.reverse(); 
	arr; // ['three', 'two', 'one']	

  g.concat

	concat()方法把当前的Array和另一个Array连接起来，并返回一个新的Array：

	var arr = ['A', 'B', 'C'];
	var added = arr.concat([1, 2, 3]);
	added; // ['A', 'B', 'C', 1, 2, 3]
	arr; // ['A', 'B', 'C']
	*请注意，concat()方法并没有修改当前Array，而是返回了一个新的Array。

	实际上，concat()方法可以接收任意个元素和Array，并且自动把Array拆开，然后全部添加到新的Array里：

	var arr = ['A', 'B', 'C'];
	arr.concat(1, 2, [3, 4]); // ['A', 'B', 'C', 1, 2, 3, 4]	

  h.join

join()方法是一个非常实用的方法，它把当前Array的每个元素都用指定的字符串连接起来，然后返回连接后的字符串：

var arr = ['A', 'B', 'C', 1, 2, 3];
arr.join('-'); // 'A-B-C-1-2-3'	

  i.split(pattern, string) 将字符串用指定的分隔符切分成数组



/***************************************  Homebrew(2017-3-12)  **************************************************/
homebrew常用命令


搜索软件：brew search 软件名，如brew search php70
安装软件：brew install 软件名，如brew install php70
卸载软件：brew remove 软件名，如brew remove php70
重新安装： brew reinstall 软件名，如brew reinstall php70
更新某具体软件: brew upgrade php70
用浏览器打开: brew home php70
显示软件内容信息: brew info php70
显示已经安装软件列表: brew list





/***************************************  操作系统-文件管理 (2017-1-10)  **************************************************/
【文件管理】
	文件的逻辑结构和物理结构
		逻辑：流式 非流式
		物理：顺序 链接 索引 

	文件存取
		文件控制块（FBC）
			-文件基本信息（文件名、描述）
			-文件修改时间
			-存取控制信息（权限）
		索引结点

	文件共享
		静态共享（软硬链接）
		动态共享（管道）

	磁盘管理
		先来先服务
		最短寻道（磁头所在磁道距离最近）
		SCAN（电梯算法）当前移动方向最近磁道
		循环扫描（单向）

/***************************************  PHP Manaul (2017-1-10)  **************************************************/
【附录】
版本历史：
	PHP 5.6.x -> PHP 7.0.x
		-新特性
			1.标量类型声明
			*2.返回值类型声明 示例：
				function sum($a,$b):float{
					return $a+$b;	//float类型
				}

			*类型声明允许函数在调用时要求参数为特定类型（在PHP7里面会跑出一个typeError）
			3.null合并操作符： ?? (如果变量存在且不为NULL返回本身，否则返回第二个操作数)
				a = b??c
			4.太空船操作符
			*5.可以通过define来定义常量数组 之前只能用const
				define('Animal',[
						'ca',
						'ca'
					])
			*6.匿名类
			7.unicode codepoint 转译语法（接受16进制形式的unicode，打印出字符串） 示例：
				echo "\u{aa}";
				echo "\u{0000aa}";
				echo "\u{9999}";
			8.Closure::call() （绑定一个方法到对象上闭包并调用它）
			9.unserialize(str) （通过白名单的方式防止潜在的代码注入）
			10.IntChar 
			11.预期
			*12.Group use declarations（同一个namespace导入的类 函数和常量，只需一个use一次性导入） 示例：

				// PHP 7 之前的代码
				use some\namespace\ClassA;
				use some\namespace\ClassB;
				use some\namespace\ClassC as C;

				use function some\namespace\fn_a;
				use function some\namespace\fn_b;
				use function some\namespace\fn_c;

				use const some\namespace\ConstA;
				use const some\namespace\ConstB;
				use const some\namespace\ConstC;

				// PHP 7+ 及更高版本的代码
				use some\namespace\{ClassA, ClassB, ClassC as C};
				use function some\namespace\{fn_a, fn_b, fn_c};
				use const some\namespace\{ConstA, ConstB, ConstC};

			13.会话选项
				session_start() 可以接受一个 array 作为参数， 用来覆盖 php.ini 文件中设置的会话配置选项。

			14.跨平台的随机函数
				random_bytes(length)
				random_int(min, max)



/***************************************  操作系统-内存管理 (2017-1-9)  **************************************************/
*内容是很多的，我这里只是意识流的归纳

起因：程序装载申请内存空间，我们自然要想办法分配管理内存

【内存的管理方式：】

	+-----------------------------+---------------------------
	+	连续管理					  + 	不连续
	+--------------+--------------+--------------+------------
	+	固定分区	   +  动态分区     +	分页 		 +   分段
	+--------------+--------------+--------------+------------
	+	内部碎片	   +  外部碎皮     +
	+--------------+--------------+

【虚拟内存技术实现：（局部性原理）

	缺页中断机制 + 页面置换（算法）

【页面分配策略

【工作集|抖动	

/***************************************  PHP Manaul (2017-1-8)  **************************************************/
函数参考-
	影响PHP行为的扩展-
		输出控制-
			基本用法：为了保证在发送http头之前，保存一般的echo输出。（因为一般输出后是不允许再发送http头的）
			示例：
				<?php
					ob_start();
					echo "Hello\n";
					setcookie("cookiename", "cookiedata");
					ob_end_flush();

			函数：
				ob_start() 			打开输出控制缓冲

				ob_clean(oid) 		清空【输出】缓冲区（必须在ob_start()启动后使用）		
				ob_end_clean(oid) 	清空并关闭缓冲区
				ob_end_flush(oid) 	输出并关闭缓冲区

				ob_get_length(oid) 		返回缓冲区长度
				ob_get_contents(oid)	返回缓冲区内容

		PHP选项-
				extendsion_loaded() 	查看扩展是否加载	return bool （CLI 下php -m可以列出所有有效扩展）
				get_cfg_var(option)		获取配置选项的值
				get_included_files(oid) 获取被include的文件名数组
				getenv(varname) 		获取环境变量的值
				ini_get(varname)		获取某个配置选项的值
				ini_set(varname, newvalue) 设置某个配置选项的值
				phpinfo() 				输出PHP配置信息
				set_time_limit(seconds) 设置脚本的最大执行时间




/***************************************  Linux EveryDay (2017-1-5)  **************************************************/
ps命令用来列出系统中当前运行的那些进程【快照】


/***************************************  Linux EveryDay (2017-1-4)  **************************************************/
文件打包上传和下载：
	打包是指将一大堆文件或目录变成一个总的文件；压缩则是将一个大的文件通过一些压缩算法变成一个小文件
源于Linux中很多压缩程序只能针对一个文件进行压缩，这样当你想要压缩一大堆文件时，你得先将这一大堆文件先打成一个包（tar命令），然后再用压缩程序进行压缩
使用tar程序打出来的包我们常称为tar包，tar包文件的命令通常都是以.tar结尾的。生成tar包后，就可以用其它的程序来进行压缩

	tar 	利用tar，可以为某一特定文件创建档案（备份文件），也可以在档案中改变文件，或者向档案中加入新的文件
		-c 		新建压缩文件
		-C 		切换到指定目录
		-b 		设置区块数目
		-B 		设置区块大小
		-d 		记录文件的差别
		-f 		指定压缩文件（要压缩的文件类 全放在这里面）

		-A 		新增压缩文件到已存在的压缩
		-r 		添加问价到已压缩文件
		-x 		从压缩文件中提取文件（解压文件）
		-k 		保留原文件不被覆盖

		-z 		支持gzip解压
		-j 		支持bzip2解压
		-Z 		支持compress解压

	解包： tar xvf xxx.tar
	打包： tar cvf FileName.tar（打包后文件名） DirName(要打包的文件)


	使用实例
实例1：将文件全部打包成tar包
命令：
tar -cvf log.tar log2012.log
tar -zcvf log.tar.gz log2012.log
tar -jcvf log.tar.bz2 log2012.log
	



/***************************************  Linux EveryDay (2017-1-2)  **************************************************/
grep 【option】【pattern】【file】【打印出符合模式的行】	全局正则文本搜索工具
		-A 		显示行数（+ 之后的内容
		-B  	显示行数（+ 之前的内容）
		-C 		显示行数（+ AB）
		-c 		计算符合规则的列数
		-d 	 	指定查找的为目录而非文件时必须指定此参数
		-f 		查找符合规则的文件内容
		-i 		忽略字符大小
		-l 		查找文件内容符合规则的文件名称 （注意和-f区分）
		-L 		上反
		

grep的工作方式:
	在文件中搜索字符串模版（模式），模版后的所有字符串被看作文件名

grep自动化脚本:
	grep可用于shell脚本，因为grep通过返回一个状态值来说明搜索的状态，如果模板搜索成功，则返回0，如果搜索不成功，则返回1，如果搜索的文件不存在，则返回2。


网络


/***************************************  Linux EveryDay (2017-1-2)  **************************************************/
磁盘储存：
	df [-option] [-file] 检查linux服务器的文件系统的磁盘（即硬盘）空间占用情况
		*默认情况下，磁盘空间将以 1KB 为单位进行显示，除非环境变量 POSIXLY_CORRECT 被指定，那样将以512字节为单位进行显示
		共六列，如下：
		文件系统    1K-块        已用     可用    已用%   挂载点
	   /dev/sda7  19840892    890896  17925856   5%     /		

		-T 		指定文件系统
		-h 		一般用户模式阅读
		-l 		本地文件

	du [-option] [-file] 对文件和目录磁盘使用的空间的查看，还是和df命令有一些区别的
		-a 		显示个别文件的大小
		-c 		除了显示个别目录或文件的大小外，同时也显示所有目录或文件的总和
		-h 		一般用户模式
		-S 		显示个别目录大小（不包含子目录）	【如果不指定选项 则默认当前所有目录】
		-X 		指定文件和目录
		-s 		总计

	df和du的区别：


/***************************************  SQL (2017-1-2)  **************************************************/
数据检索
数据过滤 （where NOT|IN  between limit having || % *  _ ）
数据分组 （）
子查询
select 子句的顺序


/***************************************  京东抢购脚本 (2017-12-28)  **************************************************/
实现了定时刷指定优惠券

/***************************************  Xpath (2017-12-27)  **************************************************/
常用路径表达式（步）：
／ 	跟节点

谓语：

通配符

运算符

轴（定义出相对于当前节点的节点集）

函数库

浏览器中的实现：
	IE浏览器中每个节点，都有selectSingleNode与selectNodes方法,传入XPath表达式,selectNodes返回匹配的节点列表，而selectSingleNode则只返回列表中第一个项目!
	代码实现：
		 var xmlDom = getXMLDOM(); //生成DOM对象
    	 loadXMLFile(xmlDom,"text.xml"); //加载xml文件
    	 var root = xmlDom.selectNodes("/*")[0];//查询

/***************************************  PHP Manaul(2017-12-26)  **************************************************/

特点章节：
	PHP 的 HTTP 认证机制

	cookie：
		Setting new cookie
		=============================
		<?php 
		setcookie("name","value",time()+$int);
		/*name is your cookie's name
		value is cookie's value
		$int is time of cookie expires*/
		?>

		Getting Cookie
		=============================
		<?php 
		echo $_COOKIE["your cookie name"];
		?>

		Updating Cookie
		=============================
		<?php 
		setcookie("color","red");
		echo $_COOKIE["color"];
		/*color is red*/
		/* your codes and functions*/
		setcookie("color","blue");
		echo $_COOKIE["color"];
		/*new color is blue*/
		?>

		Deleting Cookie
		==============================
		<?php 
		unset($_COOKIE["yourcookie"]);
		/*Or*/
		setcookie("yourcookie","yourvalue",time()-1);

	会话：	

	xForms（下一代的HTML表单）

	文件上传处理：
		A.POST方法上传文件：
			*如果表单中没有选择上传的文件，则 PHP 变量 $_FILES['userfile']['size'] 的值将为 0，$_FILES['userfile']['tmp_name'] 将为空。	
			*如果该文件没有被移动到其它地方也没有被改名，则该文件将在表单请求结束时被删除。
		B.错误信息说明	
			UPLOAD_ERR_OK	其值为 0，没有错误发生，文件上传成功。
			UPLOAD_ERR_INI_SIZE		其值为 1，上传的文件超过了 php.ini 中 upload_max_filesize 选项限制的值。
			UPLOAD_ERR_FORM_SIZE	其值为 2，上传文件的大小超过了 HTML 表单中 MAX_FILE_SIZE 选项指定的值。
			UPLOAD_ERR_PARTIAL		其值为 3，文件只有部分被上传。
			UPLOAD_ERR_NO_FILE		其值为 4，没有文件被上传。
			UPLOAD_ERR_NO_TMP_DIR	其值为 6，找不到临时文件夹。PHP 4.3.10 和 PHP 5.0.3 引进。
			UPLOAD_ERR_CANT_WRITE	其值为 7，文件写入失败。PHP 5.1.0 引进。
		C.上传多文件

	使用远程文件（开启allow_url_fopen）

	连接处理

	数据库持久连接处理
		*web服务器利用PHP生成web的三种方式
		*持久的数据库连接是指在脚本结束运行时不关闭的连接
		总结：持久连接和非持久连接主要的区别还在与 生成web时，该页面连接sql服务时效率问题

	安全模式
		？为什么取消安全模式

	命令行模式（里面东西很多）
		学到了命令行参数 ：
			argc代表脚本参数个数+1的值
			argc代表脚本参数数组 	其中$argc[0] 为脚本名称

	垃圾回收机制（当引用计数减少到0=》清楚）
		A。引用计数机制（知道了变量容器 如何区分引用变量和普通变量） 
		B。分析垃圾周期 发现垃圾

	DTrace
		包括 Solaris，Mac OS X，Oracle Linux 和 BSD 在内的很多操作系统 都提供了 DTrace 跟踪调试框架
	DTrace 可以跟踪操作系统行为和用户程序的执行情况	


/***************************************  《计算机网络》-nowcoder(2017-12-25)  **************************************************/
Nowcoder 《计算机网络》	： 关于网络地址后面跟的斜线不太懂
	解答：这种写法是网络前缀法表示子网掩码 数字代表网络号位数
子网掩码
DNS
常见协议与对应的端口号
发送窗口大小=min(接收窗口，拥塞窗口)=10KB。

/***************************************  《计算机网络》(2017-12-17 - 2017-17-24)  **************************************************/
（转眼一个周又过去了，上周的主要任务是刷《计算机网络》），回头看，却感觉没什么可记的～

/***************************************  计算机网络(2017-12-6)  **************************************************/
网络分层体系结构
	OSI（7层）：物理层、
	TCP／IP（4层）：
	五层：
其中每一层所用代表协议：
	物理层：IEEE、RJ45、CLOCK
	数据链路层：MAC、HDLC、SDLC
	网络层：IP、ARP、ICMP、DHCP
	传输层：TCP、UDP、SCTP
	会话层：SQL、PRC、NFS
	表示层：JPEG、
	应用层：FTP、HTTP、SMTP
其中每一层的主要功能如下：
	物理层：机械规范、比特传输
	数据链路层：封装成桢、流量控制
	网络层：路由转发、流量控制、拥塞控制
	传输层：可靠传输、差错控制
	会话层：建立、管理、终止会话
	表示层：对数据 进行加密、压缩
	应用层：访问、执行





ARP（地址解析协议）的工作原理：
	前提条件：每个主机都会在ARP缓冲区中建立一个列表（又称高速缓冲区）表示IP地址和MAC地址之间的映射关系

	当主机A发送数据包到主机B时，先查看列表，是否有B的IP地址，如果有查出对应的MAC地址，并将MAC地址写入MAC帧中，并通过局域网将MAC帧发往硬件地址；
如果没有，先广播获取目标主机ARP分组，写入缓冲区，发往硬件地址。
	广播发送ARP请求，单播发送ARP响应。


RARP（逆地址解析协议）：
	RARP是逆地址解析协议，作用是完成硬件地址到IP地址的映射，主要用于【无盘工作站】，因为给无盘工作站配置的IP地址不能保存。
	工作流程：在网络中配置一台RARP服务器，里面保存着IP地址和MAC地址的映射关系，当无盘工作站启动后，就封装一个RARP数据包，里面有其MAC地址，然后广播到网络上去，当服务器收到请求包后，就查找对应的MAC地址的IP地址装入【响应报文】中发回给请求者。因为需要广播请求报文，因此RARP只能用于具有广播能力的网络。




TCP三次握手和四次挥手全过程：
	三次握手：
		1、客户端发送syn包（syn=x）到服务器，进入SYN_SEND状态
		2、服务器收到syn包，【必须】确认状态（ack=x+1），发送syn包（syn=y），进入SYN_RECV状态
		3、客户端受到SYN+ACK包，确认状态（ack=y+1），进入establish状态
		（三次握手过程中，并无数据传输）
	四次挥手：
		1、主动关闭方发送一个FIN，通知被动方，即将终止数据传输	
		2、被动方受到FIN包，确认状态ACK
		3、被动方也发送一个FIN，通知主动方，即将终止数据传输
		4、主动方收到FIN，发送一个ACK


TCP和UDO的区别：
	TCP：面向字节流、面向连接（点对点）、可靠、协议（http、ftp、SMTP）、注重安全
	UDP：面向数据包、面向无连接（一对多、多对多）、不可靠、协议（DNS、SNMP、TFTP）、传输速度更快

/***************************************  Javascript(2017-12-25)  **************************************************/

HTML DOM
	节点：HTML由元素组成，每个元素都被看作一个节点 整个HTML就是一个节点树
	方法：将元素节点看作对象，针对节点进行操作，就是方法
		getElementById	-获取节点
		getElementByTagName
		getElementByClassName

		appendChild 	-增加节点
		removeChild 	-删除节点

		insertBefore(insert,previous)	-新增节点
		replaceChild(replace,previous)	-替换节点
		createElement   -创建指定的元素节点

		getAttribute 	-获取属性值
		setAttribute	-设置属性值	
	属性：元素的额外标识
		innerHTML 		-节点的文本值（注意input标签的值必须使用.val获取）
		innerText
		childNodes 		-节点的字节点
		parentNode		-节点的父节点（一个节点只能有一个父节点）

	Event:
		onClick
		onchange 		-域的内容发生改变
		onload 			-
		onselect 		-选中文本
		onfocus 		-获得焦点


		clientX			
		clientY 		（一般使用事件委托）




/***************************************  Javascript(2017-12-24)  **************************************************/
HTML DOM Style：
	Scrollbar
	Table
	Text
	position
	Layout
		-display
		-overflow
		-visibility
	border
		-bordercolor
		-BorderWidth
		-BorderStyle
	Background
		-开发；开发；


/***************************************  Linux Nowcoder(2017-12-10)  **************************************************/


/***************************************  Linux Nowcoder(2017-12-10)  **************************************************/
Linux进程间通信：管道、信号、消息队列、共享内存、信号量、套接字(socket)
Linux线程间通信：互斥量（mutex），信号量，条件变量
Windows进程间通信：管道、消息队列、共享内存、信号量 （semaphore） 、套接字(socket)
Windows线程间通信：互斥量（mutex），信号量（semaphore）、临界区（critical section）、事件（event）

内存相关问题：
	1.内存分配时产生的内零头和外零头

系统|配置环境相关问题：
	1.系统当前已经加载的所有文件系统在_________文件中得到反映。
	2.5个系统调用∶open,write,read,close,ioctl

Linux 命令相关：
	A.与用户身份相关的命令-
		1.修改用户登录ID usermod
		2.sed
	B.与磁盘相关的命令
	C.系统相关命令：
		1.系统负载
		2.GCC 变异指令

网络相关命令：
	ipconfig

文件系统：
	ext2和ext3的根本区别
	linux 2.6.* 内核默认支持的文件系统有哪些？
	软链接和硬连接



du
df 
strace
nmap
tail
head
一直搞混 Linux下的 || 和 && 







/***************************************  Linux command line (2017-11-20)  **************************************************/
【shell脚本】
	1）什么是shell脚本：
		就是包含了一系列Linux命令的文件，并能解释变量、函数
	注意事项（*）和技巧（～）：
	*注意：shell脚本要给定执行权限
	*shell脚本无须后缀名
	～shell 脚本可以用tab建实现缩进 而命令行（hang） 不行

	2）变量：
		弱类型 很奇怪先指定后增添变量符 
	*变量赋值的过程中必须没有空格【这个有点python的味道了 很严格】
	可以在同一行中对多个变量赋值

	3）here docment：
		【接受标准输入命令】《 【结束符】
	*heredoc 接受标准输入 + 结束符 （注意结束符后面不能有空格 一般使用_EOF_）

	4）shell函数：
		shell 函数声明的两种形式：
			a.function name{}  调用方法：name
			b.name (){}		   调用方法：$(name)
		*利用local来定义局部变量
		~stub 程序员用来测试的空函数 
		*shell函数必须放函数调用之前
	5）流程控制
		退出状态： 当命令执行完毕之后，会产生一个状态值 （可以通过 ¥?查看 ）0表示成功
		[]:测试表达式
			文件：
				-b 
				-e 文件存在
				-f 一般文件类型
				-r 文件可读

			字符串：
				string 字符串不为空
				-n 	   字符串长度大于0
				-z。   字符串chang度=0
				string1==string2
				string1!=string2

			整数：
				-eq =
				-ne !=
				-lg <
				-le <=
				-gt >
				-ge >=

		逻辑操作符：
			command1 && command2 （如果1为真才执行2）
			command1 || command2 （如果1为假才执行2）
		case:
			a)  ==
			???) 若单词只有3个字符
			*.txt) 
			*)

			case $REPLY in
			    0)  echo "Program terminated."
			        exit
			        ;;
			    1)  echo "Hostname: $HOSTNAME"
			        uptime
			        ;;
	6）位置参数
		什么是未知参数：命令行中独立的单词 像不带-的各种选项一样

		shell默认给出$0-$9 的参数 当然我们可以通过花括号{}来访问更多的参数 比如{$11}

		默认$0为当前执行程序的路径名
		～ $# 可以获得命令行参数个数

		如果位置参数很多 我们可以通过‘shift’移动，例：
			#!/bin/bash
			# posit-param2: script to display all arguments
			count=1
			while [[ $# -gt 0 ]]; do
			    echo "Argument $count = $1"
			    count=$((count + 1))
			    shift
			done
		代码解析：当位置参数个数>0，输出当前位置参数，count+1，位置参数向后移动一位（shift）
		input:
			[me@linuxbox ~]$ posit-param2 a b c d
			Argument 1 = a
			Argument 2 = b
			Argument 3 = c
			Argument 4 = d


	6）读取键盘输入 【可以让我们的脚本产生交互的效果】
		read 
			-a 把输入赋值到array中
			-d 
			-n 读取输入的n个字符
			-p 显示提示信息
			-t 秘密输入
			-s 超时时间
		～我们一般会指定要输入值的变量名，如没有则默认REPLY
		*read不能管道 只能重定向
	7）排错、调试、追踪
		隔离|注释代码 
		追踪： 添加 -x 选项
			#!/bin/bash -x
			# trouble: script to demonstrate common errors
			number=1
			if [ $number = 1 ]; then
			    echo "Number is equal to 1."
			else
			    echo "Number is not equal to 1."
			fi
			When executed, the results look like this:

			当脚本执行后，输出结果看起来像这样:

			[me@linuxbox ~]$ trouble
			+ number=1
			+ '[' 1 = 1 ']'
			+ echo 'Number is equal to 1.'
			Number is equal to 1.
		（可以看到执行过的每一句都能看到）

	8）字符串和数字 （参数展开）
		检查空值
			${parameter:-word} 如果参数没有设置则显示word值，反之显示parameter的值

		返回变量名
			${!variable*}
			${!variable@}

		字符串展开
			字符串长度：${#parameter}
			截取字符串：${#parameter:offset:length}


		bc 	算术运算

	9）数组  animal=(a b c)  没有逗号
		数组声明和赋值
			单个元素：name[index] = value
			多个元素：name=(value1 value2)

	    数组操作：	
	    	遍历：
	    		for i in ${animal[*|@]}
	    	push：
	    		animal+=(d e f)
	    	排序：
	    		a_sorted=($(for i in "${a[@]}"; do echo $i; done | sort))	
	    	删除：
	    		unset animal

	    计算数组元素个数：
			#animal[@]




/***************************************  Linux command line (2017-11-20)  **************************************************/
常见任务和基本工具：
【软件包管理】
	Linux发行版质量的决定因素是软件包管理系统和其支持社区的活跃性和持久性

	依赖性 ：
		在大型工程中，很多的软件包会共享一些子例程（这就叫做依赖），这些子例程一般存储在动态链接库中，在某个项目中引入软件包往往需要安装依赖，所以他们往往是同时安装的

	上层和底层软件包工具：
		底层：安装和删除软件包文件
		上层：元数据搜索和依赖解析

	两大包管理系统阵营：（有空的话可以了解一下包管理系统的运行机制）
				Debian  .deb 				Red Hat .rpm
	典型：		ubuntu						centos
	上层   		apt-get						yum
	底层 		dpkg 						rpm
	查找软件包	apt-cache search string 	yum search string
	软件包信息	apt-cache show pack  		yum info pack
	安装软件包    apt-get install pack 		yum install pack
	更新软件包	apt-get update 				yum update 
	卸载软件包 	apt-get remove pack 		yum erase pack

通过软件包文件安装软件 dpkg --install pack 		rpm -i pack		(底层工具)
	列出软件包 	dpkg --list 				rpm -qa 		(底层工具)
*检查软件包是否安装 dpkg --status pack 		rpm -q pack 	(底层工具)
	



【文本处理】
	文本的作用：
		1.网页是文本文档
		2.在E-mail中有些非文本的附件也被转换成文本表现形式
		3.在类Unix系统中，输出会以文本的格式发送到标准输出
		4.程序源码 比如说shell脚本

	相关命令：
		sort 【排序标准输入传输到标准输出】
			-f 	不区分大小写
			-n 	按数值排序
			-r  反序
			-o  输出到文件而非标准输出
			-k  指定字段排序（字段由空格或制表符当作界定符）         例： 

		uniq 【删除相邻重复行并将结果传输到标准输出】（注意必须是相邻的，所以它常常需要排好序之后才能发挥最大价值）
			-c  输出重复行次数
			-i  不区分大小写
			-u  默认 输出不重复的行

		/*	文本切割和合并  */	
		cut  【从文本行中抽取字段输出到标准输出】
			-d  指定冒号作为分隔符
		paste【从文本行中】

		join

		/*	文本比较  */
		comm 【比较文本文件 分开显示特有的文本行和共有的文本行】
			-n  指定第n列隐藏

		diff 【文件差异、版本比较工具】
			输出模式：
				1.上下文模式
				-c 
				2.统一模式（这种模式在github上看的多）
				  -u
				  更改指示符：
				  空格 共有行
				  -   删除行
				  +   添加行
		patch 【接受diff输出，然后映射到文件】（这在版本更迭中意义重大）

		后续...好多...

	【归档和备份】
		数据压缩：
			gzip 压缩文件后缀名为.gz
			gunzip 解压缩文件
				-c 	将结果输出到标准输出
				-f  强制压缩 不管文件是否存在
				-r  递归压缩目录中的文件
				-t  测试压缩文件的完整性

		数据归档：
			tar 归档文件后缀为.tar
				-c  指定文件创建归档文件 
				-x  抽取归档文件
				-r  追加具体的路径到归档文件末尾
				-t  列出归档文件内容
				-v  列表信息
			tar下的路径名默认是相对路径

			zip 【既是压缩工具也是打包工具】
				zip 
				unzip
					-r 递归 不然只有一个空目录

		数据同步
			rsync 	【本地到本地 本地到远程的文件同步】
			工作原理：	比较两边的差异，执行最小的复制达到同步

			rsync -av source destination

	【编译程序】
			



【存储媒介】
【网络系统】
【查找文件
【归档和备份】


/***************************************  Linux command line【第十三章：Vim编辑器】(2017-11-19)  **************************************************/

命令模式->(i a u o)->插入模式  A
插入模式->esc->命令模式

移动命令：
	0 	移动到当前行首
	$   移动到当前行尾
	numberG 	移动到文件的第number行
	G 	移动到文件末尾
删除命令：
	dd 	删除当前行
	5dd 删除当前行及随后的四行文本
	dG  当前-行尾
	d20G 当前-第20行

复制：
	yy
粘贴：
	p
/***************************************  Linux command line【第十一章：进程】(2017-11-19)  **************************************************/
【Linux 进程】
	对进程通俗的理解就是正在或者准备使用CPU的每一个任务程序
	通过一个进程发动另一个进程通常呗表述了父进程产生一个子进程

 	查看进程：
		ps 【查看进程快照】
		top【动态查看进程信息】

	控制进程：
		中断一个进程
		停止一个进程
		将进程放入后台执行 
			启动时立即放入后台 &
			停止后转移到后台 bg
		将进程返回到前台
			（后台运行的进程）对一切键盘输入都免疫，也不能用Ctrl+C来中断它

		通信
			skill 【-signal】 PID
				   1 HUP 挂起
				   2 INT 中断
				   9 KIl 杀死
				   15 TER 终止 （默认值）
				   18 CON 继续
				   19 SOT 停止	


/***************************************  Linux command line【第十二章：shell环境】(2017-11-19)  **************************************************/
【Linux shell环境】

	相关命令：
		printenv	只打印环境变量，不打印shell变量
		set
		export
		alias


		shell环境创建：
			登录系统>bash启动>配置文件>家目录启动文件

		登录会话启动文件一般包括：
			etc/profile	
			～/.bash_profile
		非登陆会话启动文件一般包括：
			etc/bashrc
			~/.bashrc



	*
	print、set主要是打印环境变量
	如果 shell 环境中的一个成员既不可用 set 命令也不可用 printenv 命令显示，则这个变量是别名。 输入不带参数的 alias 命令来查看它们:
	export可以导出环境变量以供其他程序使用 
	也可以通过 PATH=$PATH:$HOME/bin 增加变量到环境变量	 x 正确方式： 

	*一般对环境变量进行修改之后，要重新启动 “启动文件”（启动文件：类似于.bashrc_profile 这个还需要进一步了解）才会生效，如source .bash_profile


	shell（指接口）在shell会话中保存着大量信息，又称环境信息，这些信息数据通常被用来配置属性，如同配置文件一般。

	shell环境主要存储两种类型的数据，分别是环境变量和shell变量

	shell变量组成：bash变量 + shell函数 + 别名
	常见的shell变量：（注意这些变量只能大写）
		SHELL
		HOME
		USER
		LANG
		PATH

【Linux 文本编辑器】
	快捷键：
		0 移到行首
		A 移到行尾
		o 在当前行上方打开一行 Mac 跟Linux的相反？

	插入模式 （元音字母 a i o u）


/***************************************  Linux command line【第九章：键盘操作高级技巧】(2017-11-18)  **************************************************/



/***************************************  Linux command line【第八章：从shell眼中看世界】(2017-11-18)  **************************************************/
路径展开




/***************************************  Linux Command Line【第六章：使用命令】(2017-9-1)  **************************************************/
何为命令：
	1.可执行程序
	2.shell内建命令
	3.shell函数
	4.命令别名

分清命令的类型：


/***************************************  Linux Command Line【第五章：操作文件和目录】(2017-9-1)  **************************************************/
增删改查创建重名等等指令

/***************************************  Linux Command Line【第四章：探究操作系统】(2017-8-31)  **************************************************/
三个指令：
	less
	ls
	file 确定文件类型 （Linux中一切事物都属于文件）

/***************************************  Linux Command Line【第三章：理解文件系统树与目录跳转】(2017-8-29)  **************************************************/
【文件目录结构】文章太长
	  					可分享的 				不可分享的
	  					/opt(第三方软件)		/boot(开机与核心档)
	  		不可变的		/usr（软件）			/etc（机器相关配置文件）

	  		可变的 		/var/mail(邮箱)		/var/run /var/lock
	  					/var/spool/news(新闻组) 	

	  		不变的是指不会随着版本改变而改变的一类
	  		可分享的是指可以给网络上其他主机挂载用的目录

	  		FHS建议根目录应该小而干净

	  		【具体目录结构】

	  		根目录：
	  		+--------+--------------------------------------+
	  		+ /bin   + 系统指令
	  		+--------+--------------------------------------+
	  		+ /boot  + 开机档案
	  		+--------+--------------------------------------+
			+ /dev   + 周边设备
	  		+--------+--------------------------------------+
	  		+ /etc   + 配置文件
	  		+--------+--------------------------------------+
	  		+ /home  + 使用者目录 ～
	  		+--------+--------------------------------------+
	  		+ /lib   + 函式库 外挂
	  		+--------+--------------------------------------+
	  		+ /opt   + 第三方软件目录
	  		+--------+--------------------------------------+
	  		+ /sbin  + 设定系统环境相关指令
	  		+--------+--------------------------------------+
	  		+ /tmp   + 临时目录
	  		+--------+--------------------------------------+
	  		+ /cores + 核心目录
	  		+--------+--------------------------------------+
	  		
	  		usr目录：Unix操作系统软件资源所放置的目录
	  		+------------+-------------------------------------+
	  		+ /usr/bin   + 用户指令（除去开机）
	  		+------------+-------------------------------------+
	  		+ /usr/include + 头文件|包含档
	  		+------------+-------------------------------------+
	  		+ /usr/lib   + 
	  		+------------+-------------------------------------+
	  		+ /usr/local + 用户自行下载文件
	  		+------------+-------------------------------------+
	  		+ /usr/sbin  + 动态装载过程
	  		+------------+-------------------------------------+
	  		+ /usr/share + 放置共享文件
	  		+------------+-------------------------------------+
	  		+ /usr/src   + 源码文件
	  		+------------+-------------------------------------+

	  		var目录：
	  			/var目录是在系统运作后才会逐渐占用硬盘容量的目录。主要针对常态性变动的文件，包括
	  		缓存、登录文件信息、邮箱、数据库文件、程序文件
	  		+------------+-------------------------------------+
	  		+ /var/cache + 缓存文件
	  		+------------+-------------------------------------+
	  		+ /var/lib   + mysql放在这下面哦
	  		+------------+-------------------------------------+
	  		+ /var/lock  + 
	  		+------------+-------------------------------------+
	  		+ /var/log   + 用户自行下载文件
	  		+------------+-------------------------------------+
	  		+ /var/mail  + 动态装载过程
	  		+------------+-------------------------------------+
	  		+ /var/run   + PID信息
	  		+------------+-------------------------------------+
	  		+ /var/spool + 队列数据
	  		+------------+-------------------------------------+



	  		首先记住不可分享的（即最有特殊性的 /ect很常用）
	  		然后不可变



/***************************************  Linux Command Line【第二章：什么是shell】(2017-8-27)  **************************************************/
[shell]

【一】 shell的含义：

    首先shell的英文含义是“壳”；

    它是相对于内核来说的，因为它是建立在内核的基础上，面向于用户的一种表现形式，比如我们看到一个球，见到的是它的壳，而非核。

    Linux中的shell，是指一个面向用户的命令接口，表现形式就是一个可以由用户录入的界面，这个界面也可以反馈运行信息；

【二】shell在Linux中的存在形式：

    由于Linux不同于Windows，Linux是内核与界面分离的，它可以脱离图形界面而单独运行，同样也可以在内核的基础上运行图形化的桌面。

    这样，在Linux系统中，就出现了两种shell表现形式，一种是在无图形界面下的终端运行环境下的shell，另一种是桌面上运行的类似Windows 的MS-DOS运行窗口，前者我们一般习惯性地简称为终端，后者一般直接称为shell

【三】shell如何执行用户的指令

   shell有两种执行指令的方式，第一种方法是用户事先编写一个sh脚本文件，内含shell脚本，而后使用shell程序执行该脚本，这种方式，我们习惯称为shell编程。

   第二种形式，则是用户直接在shell界面上执行shell命令，由于shell界面的关系，大家都习惯一行行的书写，很少写出成套的程序来一起执行，所以也称命令行。

总结：shell可以说只是为用户与机器之间搭建成的一个桥梁，让我们能够通过shell来对计算机进行操作和交互，从而达到让计算机为我们服务的目的。

以上。

【四】
	shell提示符 	#代表超级权限 $代表一般用户权限




/***************************************  Linux erevyday(2017-11-8)  **************************************************/
Linux常用指令：
	【其他】
	 source又称 点文件即 .
	 	用途1：source命令通常用于重新执行刚修改的初始化文件，使之立即生效，而不必注销并重新登录
	 	用途2：编译shell文件
	 
	 sudo 	以其他身份执行命令 
	 	-u  指定用户 （默认root）

	 cron 	定时任务
	 	[minute]	[hour]	[day]	[month]	[week]	[command]	
	 	* 	代表每一段中所有可能的值
	 	， 	值的列表范围
	 	- 	值的集合范围
	 	／ 	事件执行频率

	 	-u 	指定给某个用户进行定时任务
	 	-l 	显示当前用户的cron列表
	 	-e 	编辑当前用户的cron内容
	 	-r  删除当前用户的cron内容

	 	创建cron 设置环境变量EDITOR

	 alias 给命令取一个别名 
	 	例：alias foo  = 'cd /etc;ls '	注意：使用别名之前要检查是否已经存在 | 注意分号
	 unalias删除别名

	 【文本处理 参见 linux command line 2017-11-20】
	  	




/***************************************  Linux erevyday(2017-9-13)  **************************************************/
Linux常用指令：

	【文件目录】
	ls [选项][目录名]
		-a 列出.开头隐含文件
		-A 不列出父目录
		-l 详细列出文件信息
		-r 反序排列
		-S 根据文件大小排序		在有序序列中查找总要快些
		-t 以文件修改时间排序		
	touch （新建目录）
		-d 指定文件时间戳 [[CC]YY]MMDD 
		-t 指定文件时间戳 [CC[YY]MMDDhhmm[.SS]
	cat 
		-A 显示整个文件 并显示非打印字符
		-n 对输出的所有行编号
		-b 对非空输出行编号
		>  写入,将数据定向输入到指定文件	如果文件存在则先清空，后填充  覆盖方式
		》 同上 追加方式

	nl(同cat列出文件全部内容)  
		-b t 空行不列出行号（缺省值）
		-b a 空行同样列出行号
		-n ln 屏幕左方列出行号
	tail 
		-n 显示行数（倒序）的文件内容
		-n + num  从第x行开始读取
		-f 循环读取 
	pwd 
		-P 查看当前实际目录路径
	mkdir 
		-m 同时设置权限
		-p 递归创建目录
		-v 显示创建的目录信息	

	#删除目录时必须对目录有写权限	
	rm
		-r 递归删除目录|子目录
		-i 交互sh
		-f 不给任何提示

	# 此指令不能删除非空目录
	rmdir
		-p 递归删除空目录

	mv【选项】【源文件或目录】【目标文件或目录】
		-i 	若目标文件存在，询问是否覆盖
		-t  移动多个文件到一个目录（此时目录参数在前 文件参数在后）

	cp【选项】【源文件或目录】【目标文件或目录】
		-r  复制目录及其所有文件

	ln [选项] 【file】【link】
		硬链接：ln file link
		软链接（符号链接）：ln -s file link 

			一个符号链接指向一个文件，而且这个符号链接本身与其它的符号链接几乎没有区别。 例如，如果你往一个符号链接里面写入东西，那么相关联的文件也被写入。然而当你删除一个符号链接时，只有这个链接被删除，而不是文件自身。如果先于符号链接 删除文件，这个链接仍然存在，但是不指向任何东西。在这种情况下，这个链接被称为坏链接。在许多实现中，ls 命令会以不同的颜色展示坏链接，比如说红色，来显示它们 的存在。




	 【文件查找】
	 which【选项】【指令】
	 	作用：在PATH变环境中，搜索可执行文件位置（一般是系统指令），并返回第一个搜索结果

	 	-n 	指定待查找文件的文件名长度 >所有文件
	 	例：
	 		which pwd
	 		
	 whereis
	 	作用：搜索制定二进制、帮助说明、源代码文件（以下的参数我在MacOS下均测试为非法）
	 	-b 	只搜索二进制文件
	 	-m 	只搜索帮助说明文件
	 	-s 	只搜索源代码文件

	 find
	 	作用：在目录结构中搜索文件，并执行指定的操作

	 	-name 	按文件名查找文件（引号|支持正则表达式） 	-print 	将匹配的文件输出到标准输出
	 	-perm 	按文件权限查找文件
	 	-prune 	忽略某个文件 	[find test -path "test/test4" -prune]
	 	-type 	按文件类型查找文件
	 		d-  目录
	 		f-  普通文件
	 		p-  管道文件
	 		l-  符号链接文件
	 	-size 	按文件长度查找

	grep 【option】【pattern】【file】【打印出符合模式的行】	全局正则文本搜索工具
		-c 		计算符合规则的列数
		-d 	 	指定查找的为目录而非文件时必须指定此参数
		-f 		查找符合规则的文件内容
		-i 		忽略字符大小
		-l 		查找文件内容符合规则的文件名称 （注意和-f区分）
		-L 		上反
			

	wc 【option】【file】【统计文件的行数 单词数 字节数 字数 字符数】（注意区分后三者）
		-l 		统计行数
		-c 		统计字节数
		-m 		统计字符数
		-w 		统计字数（字被定义为由空白、跳格或换行字符分隔的字符串。）






      【文件目录结构】文章太长
	  					可分享的 				不可分享的
	  					/opt(第三方软件)		/boot(开机与核心档)
	  		不可变的		/usr（软件）			/etc（机器相关配置文件）

	  		可变的 		/var/mail(邮箱)		/var/run /var/lock
	  					/var/spool/news(新闻组) 	

	  		不变的是指不会随着版本改变而改变的一类
	  		可分享的是指可以给网络上其他主机挂载用的目录

	  		FHS建议根目录应该小而干净

	  		【具体目录结构】

	  		根目录：
	  		+--------+--------------------------------------+
	  		+ /bin   + 系统指令
	  		+--------+--------------------------------------+
	  		+ /boot  + 开机档案
	  		+--------+--------------------------------------+
			+ /dev   + 周边设备
	  		+--------+--------------------------------------+
	  		+ /etc   + 配置文件
	  		+--------+--------------------------------------+
	  		+ /home  + 使用者目录 ～
	  		+--------+--------------------------------------+
	  		+ /lib   + 函式库 外挂
	  		+--------+--------------------------------------+
	  		+ /opt   + 第三方软件目录
	  		+--------+--------------------------------------+
	  		+ /sbin  + 设定系统环境相关指令
	  		+--------+--------------------------------------+
	  		+ /temp  + 临时目录
	  		+--------+--------------------------------------+
	  		
	  		usr目录：
	  		+------------+-------------------------------------+
	  		+ /usr/bin   + 用户指令（除去开机）
	  		+------------+-------------------------------------+
	  		+ /usr/include + 头文件|包含档
	  		+------------+-------------------------------------+
	  		+ /usr/lib   + 
	  		+------------+-------------------------------------+
	  		+ /usr/local + 用户自行下载文件
	  		+------------+-------------------------------------+
	  		+ /usr/sbin  + 动态装载过程
	  		+------------+-------------------------------------+
	  		+ /usr/share + 放置共享文件
	  		+------------+-------------------------------------+
	  		+ /usr/src   + 源码文件
	  		+------------+-------------------------------------+

	  		var目录：
	  			/var目录是在系统运作后才会逐渐占用硬盘容量的目录。主要针对常态性变动的文件，包括
	  		缓存、登录文件信息、邮箱、数据库文件、程序文件
	  		+------------+-------------------------------------+
	  		+ /var/cache + 缓存文件
	  		+------------+-------------------------------------+
	  		+ /var/lib   + mysql放在这下面哦
	  		+------------+-------------------------------------+
	  		+ /var/lock  + 
	  		+------------+-------------------------------------+
	  		+ /var/log   + 用户自行下载文件
	  		+------------+-------------------------------------+
	  		+ /var/mail  + 动态装载过程
	  		+------------+-------------------------------------+
	  		+ /var/run   + PID信息
	  		+------------+-------------------------------------+
	  		+ /var/spool + 队列数据
	  		+------------+-------------------------------------+



	  		首先记住不可分享的（即最有特殊性的 /ect很常用）
	  		然后不可变

	  【文件类型】
	  		普通文件 -
	  			1.纯文本文件（可见的）
	  			2.二进制文件 
	  			3.数据格式文件

	  		目录文件 d

	  		字符设备文件c 或 块设备文件b

	  		数据接口文件 s
	  			一般用于网络通信

	  		符号链接文件 l
	  			相当于windows下面的快捷方式

	  			软连接

	  			硬连接


	  【文件属性】
	  		2095112 - rw-r--r-- 1 root root 296K 11-13 06:03 log2012.log

	  		第一列文件索引节点（inode）
	  		第二列文件类型
	  		第三列文件权限
	  		第四列文件硬链接个数
	  		第五列文件属主
	  		第六列文件群组
	  		第七列文件大小
	  		第八、九列文件最后访问和修改时间
	  		第十列文件名

	  		利用索引节点查询文件是最快的，ls -i可以查看索引节点


	  	【网络命令】
	  		netstat 	显示与IP、TCP、UDP和IMCP协议相关的统计数据，检验本机各个端口的网络连接情况
	  			-a 	显示所有连线中的socket
	  			-l 	显示监控中的服务器的socket
	  			-n 	直接使用IP地址，不通过域名服务器
	  			-p 	显示正在使用Socket的程序名称
	  			-t 	显示TCP传输状况
	  			-u 	显示UDP传输状况 
	  			
	  		ping 	查看网络连接
	  			-c  限制回传次数

	  		lsof 
	  			-i 	查看端口进程应用	
	  		

	  				

/***************************************  Linux(2017-8-27)  **************************************************/
文件目录管理：
	目录操作：
		显示目录绝对路径 pwd
		显示目录详细信息 ls
		创建 	mkdir 保证目标目录下没有重名目录 | 可以同时设置权限
		复制		cp
		重命名（+移动）	mv
	*文件查找：
		Linux命令的绝对路径：which
		指定目录查找文件：find
		查找程序文件：whereis
	*文件权限：

		r(读取 4)-w（写入 2）-x（执行 1）
		u（拥有者）-g（群组）-o（其他用户）

		文件或目录的权限：chmod
		文件所属拥有者、群组：chown
		
	*文件传输（这个应该很重要，便于在不同Linux主机上管理、共享文件）
	*包管理
		yum is a package manager for Linux. It will not work on OS X. brew is a package manager for OS X.Linux
	So instead of trying to install yum to install another piece of software, you might want to try to install this software using brew directly. But beware: the package names might not be the same. Use brew search to search for packages in brew, or maybe, even better, try and find specific instructions for OS X for the software you're trying to install.'


工具命令：
	man 

系统安全：
	sudo	



/***************************************  Linux(2017-5-24)  **************************************************/
一、Linux那些事

二、Linux系统目录结构

三、Linux文件基本属性

	文件权限的一些基本概念

四、目录常用命令
	ls
		-a 
		-d
		-l

五、用户与用户组管理

六、磁盘管理

七、vi/vim






/***************************************  Laravel视频学习(2017-11-7)  **************************************************/
27-资源路由 路由列表
28-目录分类 无限极分类  数据预处理放在Model里面 返回纯净数据到控制器，控制器作逻辑判断与视图交互
29-input文本框onchange事件 排序order by  POST提交
30-添加页面展示 | 添加动作执行 | 模版分配
31-Mass Assignment（模型守卫） | create一次性插入字段到数据库
32-模版多项参数分配（compact）| 默认的父级目录分类
36-文件上传（uploadify） | 异步传输
37-提交缩略图 | 获取js属性
38-文章增删改查-文章添加 | 过滤
39-文章增删改查-文章列表 | 模版继承 | 分页（paginate） |分页模版 | 倒序查询
42-数据库迁移
43-数据库填充
54-生成配置文件 | 读取配置文件


laravel安装器为什么比composer快？ stackoverflow
laravel安装器配置 | 制定版本 stackoverflow



/***************************************  Laravel视频学习(2017-11-2)  **************************************************/
20-验证码类引入（第三方类引入） 返回到模版的信息存储在session中 
24-中间件、路由分组、url前缀 、命名空间
25-修改密码、自定义验证规则、错误提示







/***************************************  正则表达式(2017-10-17)  **************************************************/



/***************************************  正则表达式(2017-9-13)  **************************************************/
利用PHP 、 JavaScript实现常用的正则验证场景
PHP：
	preg_match[pattern,subject,matches,flags,offset]	返回匹配次数 0|1
	preg_match_all[]



	E-Mail:	/\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*/  ^\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*$
	密码：   ^(?=.*\\d)(?=.*[A-Z])(?=.*[a-z]).{8-10}$
	校验中文：^[\\u4e00-\\u9fa5]{0,}$

JavaScript:
	字面量形式： var expression = /string/flags
					expression.test(test)
	构造函数：   var expression  = new Regxp("") ; 


 /*------------Round III 正则表达式（兄弟连的课）--------------*/

--1.含义
 就是描述字符串排列模式的一种自定义语法规则。
--2.作用
 按照一定的规则，对字符信息进行比较、分割、匹配、替换、查找等工作。
--3.特点
 首先是一个字符串；
 有特定的语法规则；
 函数调用时，发挥作用（不能独立发挥作用）

--4.学什么？
 
	1.定界符 
	*除了字母、数字、反斜线\ 以外的字符都可以用作定界字符
	/ /
	{ }
	| |
	! !
	~ ~
	# #
	*一般情况下，我们都默认时用 "//"

	2.原子
	  a.任意能打印出来的字符和非打印字符(ascii码值在0-31的为控制字符，无法显示和打印 )
	  b.转义字符(\n \r \t \f )


	     将普通字符转换为特殊字符【他们在原子里表示范围，方便字符匹配】 
		\d：表示一个任意的十进制数
		\D：表示除了十进制的数
		\s：表示任意空白字符    【\n\t\r <空格>】
		\S：表示任意非空白      【^\s】
		\w: 表示任意一个单词字符 a-z A-Z 0-9 _(包括下划线)
		\W: 表示任意一个非字
		\b: 表示单词的分界处   例如:a\bhi\ba 	hi是aa的分界线
	当然，对于原子，我们可以自定义----"[]" 只要中括号里面有任意一个单词能够匹配，就返回成功。
	如：[0-9a-z] 【不要随意加空格】

	
	3.元字符
	  元字符是用来修饰原子的，不可以单独出现。
	  ^    放在定界符里时，表示必须以该表达式开头，比如字符串开头
	       放在定界符外时，表示取反

	例如：
	     $pattern = "/^one/"
	     $string  = "/onexxxxafxxxx/"	#这里必须以one开头

	     $pattern = "^/one/"	$string 在任何位置不能包含one


	  $    放在表达式最后，表示必须以该表达式结尾
      .    表示除换行符外任意一个字符
	  *    匹配前一个字符  0或无限次	
	  +    匹配前一个字符  1或无限次e
	  ?    匹配前一个字符  0或1次
	 {m}   匹配前一个字符  m次 
	 {n,m} 匹配前一个字符  n-m次
	 ()    1.作为大原子使用
	       2.提高优先级
	       3.子模式

例如：
    $pattern = "/a3*f/"
    $string  = "/xxxxafxxxx/"   $string  = "/xxxxa3fxxxx/"   $string  = "/xxxxa333fxxxx/" 
	  


	4.模式修正符号(放在定界符之外)
	  a.i 不区分大小写的匹配 如:"/abc/i"可以与abc或aBC或ABc等匹配;
	  b.m 划分为多行时匹配   例://模式为:$mode="/abc/m" 要匹配的字符串为:$str="bcefg5e\nabcdfe"
	  c.s 将字符串视为单行,换行符作为普通字符;
	  	模式为:$mode="/pr.y/";
		要匹配字符串为:$str="pr\ny";
		两者不可匹配; . 是除了换行以外的字符可匹配;
		修改下模式为:$mode="/pr.y/s";
		其中修正符s将\n视为普通字符,即不是换行;
		最后两者可以匹配;
	  d.x 将模式中的空白忽略
	  e.A 从字符串头部开始匹配
	  	$mode="/abc/A";
		可以与$str="abcsdfi"匹配,
		不可以与$str2="sdsdabc"匹配;
		因为$str2不是以abc开头;
	  f.U 只匹配最近的一个字符串,不重复匹配;

		
		如模式为:
		$mode="/a.*c/";
		$str="abcabbbcabbbbbc" ;
		preg_match($mode,$str,$content);
		echo $content[0]; //输出:abcabbbcabbbbbc;

		如果$mode="/a.*c/";变成$mode="/a.*c/U";
		则只匹配最近一个字符串,输出:abc;

		//修正符:e 配合函数preg_replace()使用,
		可以把匹配来的字符串当作正则表达式执行;

	5.应用实例
		a.邮箱验证
		(^[-.+])*@\.
		[\w!#$%&'*+/=?^_`{|}~-]+(?:\.[\w!#$%&'*+/=?^_`{|}~-]+)*@(?:[\w](?:[\w-]*[\w])?\.)+[\w](?:[\w-]*[\w])?
 		
*/

/***************************************  cache(2017-9-13)  **************************************************/

Redis与Memchace内存管理机制的不同之处：
	




/***************************************. PHP.cURL (2017-9-10)*******************************************************/


/***************************************. PHP.网络攻防 (2017-8-18)*******************************************************/
PHP 网站主要攻击方式有哪些？应该如何预防？

1.命令注入(Command Injection)
2.eval 注入(Eval Injection)
3.客户端脚本攻击(Script Insertion)
*4.跨网站脚本攻击(Cross Site Scripting, XSS)
*5.SQL 注入攻击(SQL injection)
*6.跨网站请求伪造攻击(Cross Site RequestForgeries, CSRF)
*7.Session 会话劫持(Session Hijacking)
8.Session 固定攻击(Session Fixation)
9.HTTP 响应拆分攻击(HTTP Response Splitting)
10.文件上传漏洞(File Upload Attack)
11.目录穿越漏洞(Directory Traversal)
12.远程文件包含攻击(Remote Inclusion)

13.动态函数注入攻击(Dynamic VariableEvaluation)
*14.URL 攻击(URL attack)
15.表单提交欺骗攻击(Spoofed FormSubmissions)
16.HTTP 请求欺骗攻击(Spoofed HTTP Requests)


/***************************************. PHP. 变量(2017-8-15)*******************************************************/
A.变量
1.变量名区分大小写
2.PHP变量赋值默认总是传值赋值	（改变其中一个变量不对另一变量造成影响）
*3.引用赋值 - 改动新变量的值将会影响到原始变量，反之亦然
	注意：只有有名字的变量才可以引用赋值
*变量作用域(变量范围)
	PHP 中全局变量在函数中使用时必须声明为global
*静态变量
	局部函数域存在

B.类型 	（2017-8-18）
*变量类型转换 - 类C 
*类型判定

C.运算符
	三元运算符 - ？ :
	错误控制运算符 - @（一般放在表达式之前 可能产生的任何错误信息都会被忽略掉）
	*数组运算符
	*类型运算符 - instance
		注意：子类的实例同时也是父类的实例
	*字符运算符
		a.连接运算符 - '.'
		b.赋值连接运算符  - '.='

/***************************************. PHP. PHP特点(2017-8-11)*******************************************************/



/***************************************. PHP. 超全局变量(2017-8-9)*******************************************************/

$GLOBALS-引用全局作用域中可用的全部变量
	声明和使用全局变量？：
	a.global $a
	b.$GLOBALS

$SERVER-记录服务器和执行环境信息
主要记住一下几个：
	REQUEST_METHOD
	SERVER_ADDR
	REMOTE_ADDR
	HTTP_REFERER

$FILES(参看POST方法上传文件)




/***************************************. PHP. url(2017-8-8)*******************************************************/


base64_encode(data) #使用MIME base64对数据进行编码（设计此种编码是为了使二进制数据可以一种特殊的传输；要多站额外的空间）
base64_decode(data)

urlencode(str)	#对字符串进行编码（URL也是字符串）
rawurlencode(str)	#上同（协议不同）
/**
 * TODO: 根据提供的数据生成encode编码后的字符串
 * @param query_data (array|object) 原始数据
 * @param number_prefix string 数字下标前缀
 * @param delimiter string 分隔符
 * @param enc_type  string 编码协议
 */
http_build_query(query_data,number_prefix,delimiter,enc_type)

parse_url(url，component)	#尽量正确解析URL 返回其组成部分的关联数组（这个函数返回值有好几种情况）
/**
 * component
 	scheme - 协议  如http
	host   - 主机  
	port   - 端口
	user   -
	pass   -
	path   
	query - 在问号 ? 之后
	fragment - 在散列符号 # 之后
 */


http_build_url()







/***************************************. PHP. Array(2017-7-28)*******************************************************/

 (2017-8-9）
 	serialize(value) #序列化，目的在于将复杂数据类型转换为字符串便于存储和传输
 	unserialize(str)

（2017-8-2）
	is_array(var) #检查数组中是否存在某个值
	count(var)	  #计算数组单元数目或者对象的属性个数，可递归计数（如果变量非数组和对象类型，返回1，null返回0，所以字符串也返回1）
	sort(array)	  #将数组按字典排序

	explode(delimiter, string) #将字符串分割成数组
	implode(glue, pieces) = join	   #用glue将一位数组pieces连接为一个字符串

	array_merge(array1,array2...)	#合并一个或多个数组
	array_shift(array)				#将数组开头单元移除并作为结果返回，长度减去一（重新编号）（注意返回值为弹出的数组单元）
	array_unshift(array, var)		#在数组开头增加一个或多个单元返回新的单元数目（注意返回值为新的单元数目）

	array_push(array, var)	#将传入的变量压入 array 的末尾，array的长度会自动增加（array[] = $var性能更高）（返回值为数组个数）
	array_pop(array)		#出栈	返回array的最后一个单元并将array长度减一（返回弹出的数组单元）
	array_reverse(array)	#数组反序
	


	compact(varname)	#compact() 在当前的符号表中查找该变量名并将它添加到输出的数组中(变量名成为键名而变量的内容成为该键的值)

	array_unique(array)
	array_flip(trans)		   #交换数组中的键和值




数组实质上是key-value的映射关系，所以它可以表示如哈希表、数、队、栈等等诸多结构
PHP 数组不区分索引数组和关联数组（都会解析成下标）

数组解引用（类似链式写法）
自 PHP 5.4 起可以用直接对函数或方法调用的结果进行数组解引用，之前只能通过一个临时变量。
自 PHP 5.5 起可以直接对一个数组原型进行数组解引用,如下：
	function getArray() {
    return array(1, 2, 3);
}

	// on PHP 5.4
	$secondElement = getArray()[1];

	// previously
	$tmp = getArray();
	$secondElement = $tmp[1];


数组的键（key）有一些“规范性”强制转换 如下：
	a.合乎合法整形值的字符串会被转换为整形 如“08” -> 8
	b.浮点数会被转换为整形，不过一般也没人用吧
	c.null会被转换为空（这个经常用）
	d.布尔值会被转换为整形




/* ===============================================  Cascading Style Sheets  (2017-9-6)==================================================================== */	

css 的四种引入方式：
1.行内式（style）
2.内嵌式（style）
3.倒入式（@import "x.css"）
4.链接式（<link href="x.css" rel="stylesheet" type="text/css">）

/* ===============================================  Cascading Style Sheets  (2017-6-4)==================================================================== */	
    
   /*
		学习路线:
			1.选择器
				构成[
					selector {property: value}
					派生选择器(上下文选择器)     结点之间用空格即可如: li strong li p
					id选择器
					类选择器 
					多类选择器	
					属性选择器
					如何调用样式表:
						a.外部样式表 <link rel="stylesheet" type="text/css" href="mystyle.css" />（链接样式）
						b.<style></style>（内嵌样式）
						c.内联样式<p style = ""></p> （内联样式）
				]
				*选择器分组 [共享样式]
					h1,h2,h3,h4,h5,h6 {
					  color: green;
					  }
				*
				注意[
					a.class 和 id 名称对大小写是敏感的(待证)针对HTML语言
					b.ID选择器在同一文件中只能用一次
					c.不允许有ID词表
					[]]
					.classname td 和 td .classname 的区别[反过来解释]		p.important 解释为：“其 class 属性值为 important 的所有段落”
				]
			2.Css样式
				背景[
					背景颜色 background-color 默认transparent(透明)
					背景图像 background-image:url()
						是否重复 background-repeat
				]
				文本[
					文本缩进 text-indent	5em
					文本对齐 text-align:	left|right|center|justify(两端对齐)怎么用?
					文本间隔 word-spacing	以空白格为界
					文本装饰 text-decoration 
											none(消除特效 如a链接的默认下划线)
											underline(下划线)
											overline(上划线)
											line-through(贯穿线)
											blink(闪烁)

				]
				字体[
					字体系列:	font-family
					字体风格:	font-style
											normal
											italic(斜体)
											oblique
					字体大小:	font-size	1px = 16em
				]
				链接[
					
					a:link - 普通的、未被访问的链接
					a:visited - 用户已访问的链接
					a:hover - 鼠标指针位于链接的上方
					a:active - 链接被点击的时刻
				]
				列表[
					列表标志		list-style-type:
					列表标志图像	list-style-image:
					列表图像		list-style:
				]
				表格[
					边框		border:	solid(固体)	blue(颜色)
					高度
					宽度
					
				]
				
			3.Css(盒)模型
				框模型构成[
					见图:http://www.w3school.com.cn/css/css_boxmodel.asp
					外边距（margin）、边框（border）、内边距（padding）三者组成元素框

					1.边距都是四方的
					2.外边距默认是透明的
					3.三者默认值为0

					*外边距可以是负值，而且在很多情况下都要使用负值的外边距。
				]

			4.定位
				[
					position:relative
					position:absolute
					position:static
					position:fixed
					
					注意:相对定位与绝对定位的区别与各自的应用场景
				]
			5.Css高级
				[
					块级元素：
						a.独占一行，每一个块状元素都从新的一行开始
						b.元素的盒模型可以自行设置
						c.宽度：默认与父元素的宽度一致
						d.设置：display：block
					内联元素（行内元素）：
						a.元素挤在一行
						b.宽高不可设置
						c.宽度：元素的宽度就是它包含的文字和图片的宽度
						d.设置：display：inline
					内联块状元素：
						a.设置：display:inline-block
						b.举例：img | input
						c.特点：和其他元素在一行；可以自定义盒模型
						
						*拓展：display：none 隐藏元素框
			

					3种布局模型
						1.流动模型（浏览器默认行为）
						2.浮动模型（从左到右 也可以从右到左）
						3.层模型

					盒模型：	
				]
   */


/***************************************  XCOM指令(2017-9-4)  **************************************************/
SSID PASS SEIP SEPO MYID READ SAVE
格式是指令+内容+换行
周成帅  10:43:23
如SSID12345 换行在串口发送软件那里选

/***************************************  Git(2017-8-31)  **************************************************/
Git 的前世今生
Git在不同的平台的安装方法（自行Google）
初始化Git仓库(git  init)
本地文件版本更迭-提交（+注释） 【git status | git log | git reflog】
版本回退（上一版本|下一版本）
版本管理（增加|删除）
远程连接
关联|克隆|推送



/***************************************  WebServer(2017-8-27 )  **************************************************/
webServer 实质上也是一组程序，这组程序负责绑定服务器IP地址和由客户端发起的请求的端口地址，通过http协议来获取服务器上的资源
Apache 
Nginx
Tomcat Apache软件基金会的另一个项目，一般作为java serverlet 的应用容器，可以动态返回页面资源

*辅助知识点（URL Rewrite）：

A、有什么用？
	1，首先是满足观感的要求。
	对于追求完美主义的网站设计师，就算是网页的地址也希望看起来尽量简洁明快。形如http://www.123.com/news/index.asp?id=123的网页地址，自然是毫无美感可言，而用UrlRewrite技术，你可以轻松把它显示为 http://www.123.com/news/123.html。
	2，其次可以隐藏网站所用的编程语言，还可以提高网站的可移植性。
	当网站每个页面都挂着鲜明的.asp/.aspx/.php这种开发语言的标记，别人一眼即可看出你的网站是用什么语言做的。而且在改变网站的语言的时候，你需要改动大量的链接。而且，当一个页面修改了扩展名，它的pagerank也会随之消失，从头开始。我们可以用UrlRewrite技术隐藏我们的实现细节，这样修改移植都很方便，而且完全不损失pagerank。
	3，最后也是最重要的作用，是有利于搜索引擎更好地抓取你网站的内容。
	理论上，搜索引擎更喜欢静态页面形式的网页，搜索引擎对静态页面的评分一般要高于动态页面。所以，UrlRewrite可以让我们网站的网页更容易被搜索引擎所收录。
B、如何重写（规则）？





/***************************************  Shell(2017-5-24)  **************************************************/

原生shell：
	设计语言
	程序语言
	执行程序

现在说的shell 多半是指shell脚本 Linux下使用最多的是Bash shell 好了了解到这OK







/***************************************. NoSql(2017-8-21)*******************************************************/
	NoSql = Not only Sql 



/***************************************. PDO(2017-8-18 参见pdo.php)*******************************************************/
	PDO 提供一个数据访问抽象层，不管使用哪种数据库，都可以用相同的函数来查询和获取数据，但是PDO本身并不能实现任何数据库功能。具体流程是源数据库
实现PDO驱动，安装PDO扩展，声明源数据库类型，连接。
PDO 的事务语法主要是针对不支持事务的数据库作出的应对，如果数据库支持事务，那么数据库的操作将会自动调用隐式事务

*数据库的预处理语句





/***************************************. Java(2017-6-20)*******************************************************/

Java 构成：
	1.Java 虚拟机 、 Java 应用编程接口
	2.Java 分为三个体系
		a.JavaSE Java标准版
		b.JavaEE Java企业版
		c.JavaME Java微型版

JDK和JRE的区别？
	JDK是Java的开发环境，包含JRE
	JRE是Java的运行环境，包含于JDK

面向对象的基本概念：
	面向对象主要包含了四个主要原则：抽象、封装、多态、继承
		1.在计算机科学中，抽象就是用语义的形式描述数据和程序，隐藏其实现细节
		2.将数据和方法包装至一个类型中，并通过访问控制隐藏相关的实现逻辑通常叫做封装
		3.继承是一个对象获取其父类对象属性和行为的一种机制
		4.多态指的是我们创建的函数或引用的对象在不同的运行上下文中表现出不同的行为状态。 

包的基本概念：
	 包（package）是Java提供的一种区别类的名字空间的机制，是类的组织方式，是一组相关类和接口的集合，它提供了访问权限和命名的管理机制

抽象类的基本概念：
	抽象类的作用类似“模板”，其目的是要设计者依据它的格式来修改并创建新的类，但是并不能直接由抽象类创建模板，只能通过抽象类派生出新的类，然后再由子类进行创建对象

Java中常用网络协议：
	TCP／IP
	UDP

列出Java中的两个图形包：
	1.java.awt
	2.java.awt.image

Java连接数据库的常用类：
	1.DriverManager 类
	2.Connection 类
	3.StateMent 类
	4.ResultSet类

变量的作用范围：

在Java中，变量的作用域分为四个级别：类级、对象实例级、方法级、块级。

	1.类级变量又称全局级变量或静态变量，类级变量在类定义后就已经存在，占用内存空间，不需要实例化就能访问
	2.对象实例级变量就是成员变量，实例化后才会分配内存空间，才能访问。
	3.方法级变量就是在方法内部定义的变量，就是局部变量。
	4.块级变量就是定义在一个块内部的变量		


Java语言的特性和优点

	特性：
		1.内存自动管理
		2.去除指针
		3.取消多继承
		4.避免语句混淆
	优点

		1.简洁有效
		2.高可移植性
		3.跨平台
		4.面向对象
		5.具有多线程处理能力
	
/***************************************. Mysql(2017-6-8)*******************************************************/
mysql 基本操作：
	delete是删除数据表记录
	drop是删除数据表或数据库的

	UNION 默认去除重复的数据所以可以不用 DISTINCT 修饰符
	ORDER BY 默认升序排列

	

Mysql 数据类型：
	一、数值

	二、日期／时间
		TIMESTAMP  混合日期和时间值

	三、字符串

InnoDB 与 Myisam 的区别：











/***************************************  PHP  **************************************************/






<?php

	/*----  Round I  -----*/
一、数据类型：
	9种原始数据类型-
	查看数据类型的方法？
		1.var_dump(expression)
		2.gettype(var)
	判断数据类型的方法？
		is_type函数群即：
		【
				is_array -- 检测变量是否是数组
				is_bool --  检测变量是否是布尔型 
				is_callable --  检测参数是否为合法的可调用结构 
				is_double -- is_float() 的别名
				is_float -- 检测变量是否是浮点型
				is_int -- 检测变量是否是整数
				is_integer -- is_int() 的别名

				is_long -- is_int() 的别名
				is_null --  检测变量是否为 NULL 
				is_numeric --  检测变量是否为数字或数字字符串 
				is_object -- 检测变量是否是一个对象
				is_real -- is_float() 的别名
				is_resource --  检测变量是否为资源类型 
				is_scalar --  检测变量是否是一个标量 
				is_string -- 检测变量是否是字符串
			】
	数据类型的强制转换？
		1.C语言风格的强制转换-在要转换的变量之前加上用括号括起来的目标类型：
			$foo = 10;   // $foo is an integer
			$bar = (boolean) $foo;   // $bar is a boolean
		   【注意：如果要转换的对象不是变量而是表达式的话，表达式也需要用括号括起来】
		2.settype(var, type)
		   【注意：any digit except 0 or -0 are considered true in boolean, and any string except '0' or '' are also considered true.】

	
二、时间与日期:
	 	
	UNIX 时间戳（英文叫做：timestamp）是 PHP 中关于时间与日期的一个很重要的概念，
	它表示从 1970年1月1日 00:00:00 到当前时间的秒数之和。

	echo time().PHP_EOL;	//当前时间戳	
	echo date('Y-m-d H:i:s',$a).PHP_EOL;		//格式化当前时间	参数$a默认是time()，即当前本地时间
	echo strtotime(date('Y-m-d'));	//将时间字符串转化为时间戳
	date_default_timezone_set('Asia/Shanghai');		//修改时区
	date(format,timestamp)
	参数 	描述
	format 	必需。规定时间戳的格式。
	timestamp 	可选。规定时间戳。默认是当前时间戳（unix）。
	return 	string 返回值类型为字符串


三、字符串处理
	trim(str)系列


四、文件系统
	扩展不需要安装，它们是PHP核心的一部分，属于预定义范围，不过某些函数受php.ini的影响
	文件系统使用streams作为资源类型

	相关知识：(P.S 其实像这种东西更多的不是去记住，而是有这个意识，知道文件包含了这些东西，用的时候查一查就知道了)
		文件属性「
			filemtime(filename)//文件修改时间
			filesize(filename)//文件大小
			filetype(filename)//文件类型
		」


		路径函数「
			1.basename(path，suffix)	返回最近路径
			<?php
				echo "1) ".basename("/etc/sudoers.d", ".d").PHP_EOL;
				echo "2) ".basename("/etc/sudoers.d").PHP_EOL;
				echo "3) ".basename("/etc/passwd").PHP_EOL;
				echo "4) ".basename("/etc/").PHP_EOL;
				echo "5) ".basename(".").PHP_EOL;
				echo "6) ".basename("/");
			
				1) sudoers
				2) sudoers.d
				3) passwd
				4) etc
				5) .
				6) 
			2.dirname(path)返回目录部分
			3.realpath(path)返回被规范化的 绝对路径		Thinking : 绝对路径是怎么实现的？
			4.pathinfo(string $path,int $options) 返回文件相关信息（注：如果跟上后面的参数，则会返回一个字符串）
			
				$path_parts = pathinfo('/www/htdocs/inc/lib.inc.php');

				echo $path_parts['dirname'], "\n";
				echo $path_parts['basename'], "\n";
				echo $path_parts['extension'], "\n";
				echo $path_parts['filename'], "\n"; // since PHP 5.2.0

				输出：
				/www/htdocs/inc
				lib.inc.php
				php
				lib.inc
			
			5.parse_url(url,format)	
				return：
					scheme - e.g. http
					host
					port
					user
					pass
					path
					query - after the question mark ?
					fragment - after the hashmark #
				?>

			6.$_SERVER（路由就是通过这个解析的，主要记住一下的参数）
				SERVER_ADDR	服务器地址
				REMOTE_ADDR 客户端地址
		」

		文件判断函数「
			<?php
				is_dir(filename)//判断给定文件名是否为目录
				is_uploaded_file(filename)//判断文件是否通过HTTP POST方法上传
				file_exists(filename)//判断文件或目录是否存在
			?>
		」

		文件读写「
			<?php
			/**
			 * @param filename 要写入的文件对象
			 * @param string   要写入的字符串
			 * 【注意：默认是覆盖的，追加方式需要添加参数FILE_APPEND】
			 */
			file_put_contents(filename, data)
			/**
			 * @param filename 要读取的文件名读入字符串
			 */
			file_get_contents(filename)


			fopen(filename, mode)
			/**
			 * @param handle 由fopen创建的resource资源
			 * @param string 要写入的字符串
			 * 【注意：fwrite是默认追加的】
			 */
			fwrite(handle, string)

			fread(handle, length)
		」





三、http(超文本传输协议)
	输入网址，按下回车键这一刻，发生了什么？



四、session|cookie
		
	cookie:    
	  定义：是存放在浏览器的一个资源句柄，由名称、值、有效时间、路径、域组成。
	  作用：用来追踪用户浏览
	  Max：4k
	  *30  | 50 
	  *当前设置的Cookie不是立即生效的，而是要等到下一个页面或刷新后才能看到.
	   这是由于浏览器要给服务器一个确认的回复，在设置的这个页面里Cookie由服务器传递给客户浏览器，在下一个页面或刷新后浏览器才能把Cookie从客户的机器里取出传回服务器的原因。


	session： 
	  *是存放在服务器的一个资源句柄，由名称、值、有效时间、路径、域组成。
	  *
	  *
	SESSION配置
	; http://php.net/session.use-trans-sid
	session.use_trans_sid = 0
	
	; http://php.net/session.save-path
	session.save_path = "c:/wamp/tmp"
	
	; http://php.net/session.use-cookies
	session.use_cookies = 1
	
	; http://php.net/session.use-only-cookies
	session.use_only_cookies = 1
	
	; http://php.net/session.name
	session.name = PHPSESSID
	
	; http://php.net/session.cookie-lifetime
	session.cookie_lifetime = 0
	
*/

	/*
		没有完成的：
		数组排序
		数组填充
		数组递归
		数组拷贝【引用运算符】
		数组键值的强制转换
		如果在数组定义中多个单元都使用了同一个键名，则只使用了最后一个，之前的都被覆盖了。
		键名：
			如果为字符串，那么一定要加上单引号，否则会成为裸字符串。
			如果为常量或者变量，则不需要加单引号
	*/
	a.PHP标记 | 分隔
		*PHP实际上是有4种标记的  |这种兼容性最高
		*输出大段文本的时候，使用高级分离术，往往效率更高
		*文件末尾的结束标记往往省略更好 |尤其是在使用include和require
		
	b.数据类型
		*TRUE | FALSE 在PHP是不区分大小的
		*浮点数是不能直接比较的
		*[#
			PHP不支持unicode 是指PHP文件以Unicode编码保存不会被解析，
			会直接作为静态页面输出源代码，其实以UTF8带BOM格式保存也是有问题的。
			PHP没有处理BOM头的机制，带BOM的编码格式都不行。
			我们通常用UTF8无BOM格式，或者GBK（GB2312）
		]
		
	/////////////////////////////////////////////////////////////////////	
		string {
			查找字符串字符第一次出现的位置｛strpos | stripos(不区分大小写)｝
			查找字符串字符最后一次出现的位置｛strrpos | strripos(不区分大小写)｝
			
			提取字符串｛strstr | stristr（不区分大小写）｝
			substr
			
			替换字符串｛str_replace｝
			
			分隔｛explode(将字符串分割为数组) | implode（将一位数组拼接成字符串）｝
			
			去除空格｛trim｝
			
			
			
		}
	//////////////////////////////////////////////////////////////////////	
	
	
	【数组】
	/////////////////////////////////////////////////////////////////////	
		array{
			*键名可以重复 但会覆盖键值
		}
		
    current() - 返回数组中的当前元素的值
    end() - 将内部指针指向数组中的最后一个元素，并输出
    next() - 将内部指针指向数组中的下一个元素，并输出
    prev() - 将内部指针指向数组中的上一个元素，并输出
    each() - 返回当前元素的键名和键值，并将内部指针向前移动
	reset() 函数将内部指针指向数组中的第一个元素

		
	//////////////////////////////////////////////////////////////////////	
	
	
	c.变量
		*变量区分大小写
		*传值赋值 | 引用赋值
		*使用未初始化的变量会发出 E_NOTICE 错误
		
		
	d.常量
		*常量也区分大小写
	
	f.函数
		*必须在调用函数之前，定义函数
		*PHP不支持函数重载
		[
			重载函数是函数的一种特殊情况，为方便使用，C++允许在同一范围中声明几个功能类似的同名函数，
			但是这些同名函数的形式参数（指参数的个数、类型或者顺序）必须不同，
			也就是说用同一个运算符完成不同的运算功能。
		]
		*函数名不区分大小写
		*可变函数的概念	这种非典型概念，不需要深入探究，但需要了解
		*匿名函数（闭包函数） 一般是临时创建用以回调的函数
		
		
		
		
		
	
	1.数据类型
		Array
	    [数组的定义方式(键值对): 
			array('A' => 'B')
			['A' => 'B']     //5.4
		]
		*数组和对象不能用作键名
		*键名强制转换的几种方式
		*常用的数组函数
		*索引数组是 键值为数字的一种特殊的关联数组形式
		 索引数组有三种赋值方法:
		[
		 $arr[0]='苹果';   
		 array('0'=>'苹果');
		 array('苹果');
		]
				 
		*关联数组 是指数组的键是字符串的数组
		*遍历数组
		 for()[数组下标]
		 foreach()[键值对]
		/*
			数组不能一次返回多个值,但可以返回数组.
		*/ 
		
		callback 回调类型
		
	2.[变量]
        *变量名是区分大小写的。
		*PHP默认传值赋值
		*引用赋值,会导致原变量也发生改变
		*静态变量
		[
			例:
				<?php
	 function  test ()
	{
		static  $a  =  0 ;
		echo  $a ;
		 $a ++;
	}
	 ?> 
		]
	   *可变变量 [${$a}]
	   
	3.[常量]
		*常量定义{
			define
			const[类定义常量]
		}
		*魔术常量[常用]
		*表达式[everything is expressition]
		 ++$ [先增加 再赋值]
		 $++ [先赋值 再增加]
		 
	4.[函数]
		*一般来说,函数可以即用即调[除非函数被包裹在条件控制语句里面]
		*函数参数{
			默认值一定是表达式形式
			默认参数必须放到右侧[
			<?php
			 function  makeyogurt ( $flavour ,  $type  =  "acidophilus" )
			{
				return  "Making a bowl of  $type   $flavour .\n" ;
			}
			echo  makeyogurt ( "raspberry" );    // works as expected[$flavour $type位置不能调换]
			?> 			
			]
		}
		*可变函数[函数名赋予变量,变量()调用函数]
		[例:
			  function name() {
			  echo 'jobs';
		 }
			$func = 'name';
			$func(); //调用可变函数
		]		 
		*匿名(闭包)函数
		  临时创建一个没有指定名称的函数,经常用作回调函数(callback)
		  [参考JQuery .get方法]
		
	
	
	



	
/*
	4.SQL注入与防范
	  *SQl注入实质上是由于没有有效地控制输入数据
	  *注入方式
	  
	防范手段
	  *过滤字符串
	  *正则表达式约束
	  *条件约束
	  *PDO 数据预处理
	  
*/
	
	


 /* 
3.声明
	<?php
	// 声明一个类 
	class Person{
		// 成员属性 
		var $name;
		var $age;
		var $sex;
		
		function say(){
			echo "hello";
		}
	}
	// 通过类创建（实例化）对象
	$p1 = new Person;
	
	// 调用对象属性 
	$p1->name  = "zhangsan";
	echo $p1->name;
	
	// 调用对象方法 
	echo "<br/>";
	$p1->say();
	
?>
*/


4.访问控制的关键字代表的意义为：

public 表示全局，类内部外部子类都可以访问[var视为公有]
private表示私有的，只有本类内部可以使用；
protected表示受保护的，只有本类或子类或父类中可以访问；
  [除了public，其他两种都不能通过外部访问，可以用this关键字进行内部访问。


*类中的方法可以被定义为公有，私有或受保护。如果没有设置这些关键字，则该方法默认为公有。 
*同一个类的对象即使不是同一个实例也可以互相访问对方的私有与受保护成员。这是由于在这些对象的内部具体实现的细节都是已知的。 
  
5.this关键字
  对象的方法都默认有一个关键字 "this" 用来调用当前对象的属性与变量。

6.构造方法与析构方法
-------构造方法：
--目的：初始化变量
--特点：对象第一时间调用；对象一旦实例化，自动调用

--构造方式
  1.方法名与类名相同            PHP4.0
  2.__construct(魔术方法的一种) PHP5.0
    魔术方法的优点，就是改变类名时，不需要改变方法名。

【例子】


	class Person{
		var $name;
		var $age;
		var $sex;
	// PHP4.0 构造方法	
		function __construct($name="zhangsan",$age="20",$sex="男" ){
			// 用户可以自己传值初始化变量 
			echo $this->name="$name";
			echo $this->age="$age";
			echo $this->sex="$sex";	
		}
	
	// PHP5.0 构造方法——魔术方法
//		function __construct($name="",$age="",$sex=""){
//		echo $this->name="$name";
//			echo $this->age="$age";
//			echo $this->sex="$sex";	
//		}
		
	}
	// 创建对象后，自动调用方法 
		$p1 = new Person;
		echo "<br/>";
		echo "--------------------------------------";
		echo "<br/>";
	// 创建对象后，自动调用方法，且自己赋初值
//		$p2 = new Person("wangwu",10,"女");


		
7、static关键字
   (1)静态属性与非静态属性的区别
静态属性就是声明一个属性，当我们就某一个类创建多个对象时，该属性可以被多个对象共享，不需要重复创建、删除属性。

   (2)使用关键字static修饰的方法（函数），称之为静态方法，静态方法【不需要实例化对象】，可以通过类名直接调用，操作符为双冒号::  |
      [可以[类名::静态方法] 也可以[实例化对象::静态方法] 但不能[实例化对象::属性]]
class Car {
    public static function getName() {
        return '汽车';
    }
?}
echo Car::getName(); //结果为“汽车”

   (3)static修饰的属性方法调用 ---------- 类名::静态成员
  为了防止类名频繁变动，调用不便，我们用self代表本类。所以(2)也可以写为：
class Car {
    public static function getName() {
        return '汽车';
    }
?}
echo Car::getName(); //结果为“汽车”
  
   (4)静态方法里，不能访问静态成员，非静态方法里，可以访问静态变量
    *由于静态方法不需要通过对象即可调用，所以伪变量 $this  在静态方法中不可用。 
    *self代表本类,只能在内部使用
	
7、遍历对象
	如果要遍历非可见属性,记得用$this.
	[
		<?php
	 class  MyClass	 {
		public  $var1  =  'value 1' ;
		public  $var2  =  'value 2' ;
		public  $var3  =  'value 3' ;

		protected  $protected  =  'protected var' ;
		private    $private    =  'private var' ;

		function  iterateVisible () {
		   echo  "MyClass::iterateVisible:\n" ;
		   foreach( $this  as  $key  =>  $value ) {
			   print  " $key  =>  $value \n" ;
		   }
		}
	}
	$class  = new  MyClass ();
	foreach( $class  as  $key  =>  $value ) {
		print  " $key  =>  $value \n" ;
	}
	echo  "\n" ;
	$class -> iterateVisible ();
	?> 
		
	以上例程会输出：

	var1 => value 1
	var2 => value 2
	var3 => value 3MyClass::iterateVisible:
	var1 => value 1
	var2 => value 2
	var3 => value 3
	protected => protected var
	private => private var
	]
	--------------------------------------------------------------------------------------
		以下内容 基于PHP手册
-------------------------------------------------------------------------------------
8.范围解析操作符
  *访问静态成员(属性|方法) | 类常量
  *php5.3新增变量引用类[
	<?php
	 class  MyClass  {
		const  CONST_VALUE  =  'A constant value' ;
	
	$classname  =  'MyClass' ;
	echo  $classname :: 
  ]
  
  *在类[定义外]引用上述项目 
   a.类名::项目
   b.实例化对象名::项目
  *在类定义[内]引用上述项目 
   [self parent static]关键字
   (务必严格遵守上述规则)   
   [例
		参见手册[范围解析操作符]
   ]
   
9.继承 
  *  除非使用了自动加载，否则一个类必须在使用之前被定义
  *  除非子类覆盖了父类的方法，被继承的方法都会保留其原有功能
  *  调用父类的方法,我们只需要parent::function()
   
   
8、封装[private]
	(1)方法
	当一个类需要大量的方法，我们尽量避免将代码全写在一个方法里面，而是将代码分散在多个方法中，然后将各个方法组合
封装在一个方法中(private 这样对外(用户)就隐藏起来了)。这样类似分层机制,分散变成压力,二是能够避免某个不完整的方法暴露.
	(2)属性
	防止外部随意改值(非法值)破坏从而对象
	(3)重载(动态的创建)
	__set() 
	__get()
	__isset()
	__unset()  [魔术方法自动调用]
	[例:
		function __get($proName){
			echo "----";
			/*	必须传入参数	*/
		}
	]
	
	
	/*------------Round II  命名空间--------------*/
1、命名空间：
   是用namespace关键字声明，用来防止命名冲突的一种封装事物的方法。
   注意[
		*namespace之前不能有任何输出 (顶格输出)
		*不是任何类型的数据都能作为命名空间的范畴
		*反斜杠
		*不能有特殊符号如点号
   ]
   
   
  
   /*------------Round IIII TP框架--------------*/
/*   
--1.ThinkPHP
   框架：一系列结构代码的集合
   MVC： 通用的设计模式
		 M:数据的读取操作
		 V:数据的输出展示
		 C:核心调度器
	学习流程：
		a.基础概念、文件配置
		
	项目文件配置
	*  1.分组部署 独立 | 共享
	*  2.自定义文件配置需要事先加载  'LOAD_EXT_CONFIG' => **
	*  3.加载项目文件 (分析URL访问模式  加载模块  调用控制器)
	
		b.文件内涵、项目执行流程【重点】
		
	项目执行流程：
	*  1.加载./ThinkPHP/ThinkPHP.php文件
	*  2.加载./ThinkPHP/lib/core/ 类库
	*  3.加载项目文件 分析URL访问模式  加载模块  调用控制器 调用方法
	
	
	
	
		c.URL访问模式[参看手册5.1]
	*1      pathinfo模式   默认(THINKPHP核心配置文件)
	*0          普通模式
	*2          重写方式
	*3          兼容方式
	*配置URL模式  URL_MODEL =>
	
		c.U方法(
		*一般用于生成URL地址
		*自动匹配URL模式	
	)：U('INDEX/user',array('id'=>1),'html',false[是否跳转],'localhost'[]);
	
	*分解：http://localhost/thinkphp/index.php/Index/index
	*      index.php是应用的入口文件
	*	   Index是lib/Model/的模板文件
	*	   默认是Index控制器 index方法
	*      index是lib/Action/IndexAction.class.php类中的方法
	
	
		c.URL隐藏
		  * 创建.htaccess文件时,一定不能带后缀.
		  * URL_MODEL => 2
		  * 
	
	    c.URL伪静态
设置页面伪静态，关键是让页面后缀静止，方便搜索引擎抓取。	
	*URL_HTML_SUFFIX => '配置伪静态后缀名'

		d.配置文件、函数库
	*C方法在ThinkPHP/common/common.php
	*U方法在ThinkPHP/common/functions.php
	*根据项目的需求，我们在不同的项目里建立特定的函数
	*LOAD_EXT_FILE => /common扩展函数文件
	*DEFAULT_FILTER => htmlspecialchars  I函数的过滤函数,防止脚本注入
	
		e.模板技术
	*建立模板  TPL下建立与控制器名相同的文件夹
	*调用模板  $this->display();
	*模板赋值  $this->assign('变量名','变量值')->assign('变量名','变量值')
	*模板输出  直接在模板文件里echo 
	*扩展模板(引入CSS JS 文件)  TMPL_PARSE_STRING =>array(
							'__Public__'=> __ROOT＿　．'APP_NAME' . '/tpl/Public'
	)
    *模板后缀  TMPL_TEMPLATE__SUFFIX => 'HTML|htm'
	*模板路径  TMPL_FILE_DEPR => '_'
	
		f.数据库操作
	*数据库信息配置 主从服务器配置
	*数据库连接 实例化模型
		1.基础实例化
		$user = new Model('表名','表前缀','数据库信息')  ==  （M方法）$user = M('表名','表前缀','数据库信息')
		2.自定义实例化
		路径：    lib/Model
		命名规则：xxModel.class.php   xx为模块名
		3.公共模型实例化
		公共模型实例化也属于自定义实例化。
		4.空模型实例化
		$model = new Model();
		*@param return    array      $model->query($sql);  读取数据select 
		*@param 写入行数  int        $model->execute($sql) 写入数据insert update
		*@param sql语句   string     $model->getlastsql    获取上一条sql语句
	*数据库CURD操作
		*add|    M('cat')->add($data);       $data = array()
		
		*addall| M('cat')->addall($data)     $data = array(0=>array(),1=>array())
		
		*update| M('cat')->where(sql语句条件)->save($update)   注意update 指更新的数据
		
		*select| M('cat')->where(sql语句条件)->select()
		
		*delete| M('cat')->where(sql语句条件)->delete()
		
		*$User->where('id=5')->setInc('score',3); // 用户的积分加3  直接用数据库里的字段
		*$User->where('id=5')->setInc('score'); // 用户的积分加1
		*$User->where('id=5')->setDec('score',5); // 用户的积分减5
		*$User->where('id=5')->setDec('score'); // 用户的积分减1
		
		||||||||||||||||||||||||||||||||
		||||||||||||||||||||||||||||||||
		||||||||||||博客开发 日志|||||||
		||||||||||||||||||||||||||||||||
		||||||||||||||||||||||||||||||||
	1.独立分组下的JSS CSS文件引入 
		__Public__默认在应用同目录下的Public文件夹下面,可以通过TMPL_PARSE_STRING =>array(
							'__Public__'=> __ROOT＿　．'APP_NAME' . '/tpl/Public'
	)进行个性化设置
	2.尽量去掉后缀名,不然会链接无效  TMPL_TEMPLATE__SUFFIX => 'HTML|htm' 或者利用U函数传递空值
	3.引入个人扩展类
		a.放到/thinkPHP/extend/library/ORG/Util 但可能会被官方更新冲掉
		b.放到Modules同级目录下的Class(新建)下  import('@.Class.类名',APP_PATH);
		
 */  
   -------------------------------------TP MANAUL--------------------------------------------------
   [项目配置]
      *格式  一级参数不区分大小写 二级参数区分大小写
	  *默认  ThinkPHP/Conf/convention.php 有很多的默认配置可提供参考
	  |查看ThinkPHP版本号|  ThinkPHP/Common/runtime/20line
	  
   /* ===============================================  JavaScript   ==================================================================== */
  /*
	学习曲线(入门):
		一般调试方法：
			

// // var str = 'hello world';
// // alert(str.indexOf(world));
// // alert（str.substring(0,5)）;

// // 或者
// // var str = 'hello world';
// // console.log(str.indexOf(world));
// // console.log(str.substring(0,5));
// // 或者

// // 打开浏览器，按下f12健后，在控制台输入

// // 前面两种写法，需要写成单独的js文件，或者嵌入到html文件中

	
		1.大致了解一下JS的历史|现状
		2.入门——引入JS 标签<script></script>
		3.基本语法
		4.输入输出
			*“+”字符串连接赴
			*输出多项内容，内容之间用+号连接
			*输出HTML标签，并起作用，标签使用""括起来 document.write(mystr+"<br>")
			*输出空格 &nbsp
		弹窗 可以看作用户事件
		[
			5.警告
			6.确认
				*返回布尔值
			7.提问
				*用户交互的信息
					prompt(str1, str2);
				*参数说明：
					str1: 要显示在消息对话框中的文本，不可修改
					str2：文本框中的内容，可以修改
				*返回值:
					1. 点击确定按钮，文本框中的内容将作为函数返回值
					2. 点击取消按钮，将返回null
		]
		
		8.窗口
  
		9.DOM文档结构
		 HTML文档可以说由节点构成的集合，三种常见的DOM节点:
		*元素节点：上图中<html>、<body>、<p>等都是元素节点，即标签。
		*文本节点:向用户展示的内容，如<li>...</li>中的JavaScript、DOM、CSS等文本。
		*属性节点:元素属性，如<a>标签的链接属性href="http://www.imooc.com"。
		
	   10.getElementById
	   
	   11.innerHTML
	    *元素对象 一般通过ID获取
		*区分大小写
		*获取|替换 原网页的内容
	
	学习曲线(进阶):
		1.数据类型与变量
			*Var还可以一次声明多个变量，变量之间用","逗号隔开
			*number 不区分整数和浮点数
			*一定要坚持运用'==='不要用'=='
			*null表示一个空的值，而undefined表示值未定义[区别不大,多用null]
			*数组可以包括任意数据类型
			*变量严格区分大小写
			*strict模式
		2.字符串
			*[``]打印多行字符串
			* '+'
			*模版字符串： 自动填充
			* 不可以对字符串的索引赋值[无效的]
		3.操作符之间的优先级
			* 算术操作符 → 比较操作符 → 逻辑操作符 → "="赋值符号(由高到低)
		4.数组[JavaScript数组可以越界 但会改变数组]
			*数组都是变长的，也就是说即使指定了长度为8，仍然可以将元素存储在规定长度以外
			*Array A必须大写
			*创建数组方式: var myarray = new Array(66,80,90,77,59)
						   var myarray = [66,80,90,77,59]
			*数组长度 arr.length [点语法]【直接给Array的length赋一个新的值会导致Array大小的变化】
			*myarr[0][1] ,0 表示表的行，1表示表的列。
			*直接给Array的length赋一个新的值会导致Array大小的变化[会自动增添undefined|去除元素]
			
			【内置一些数组帮助函数】
			*slice()[slice()的起止参数包括开始索引，不包括结束索引]【不传入参数，将会copy数组】
			*push()向Array的末尾添加若干元素，pop()则把Array的最后一个元素删除掉
			*往Array的头部添加若干元素，使用unshift()方法，shift()方法则把Array的第一个元素删掉
			*sort 默认字典排序
			*reverse 数组反转
			*splice()方法是修改Array的“万能方法”，它可以从指定的索引开始删除若干元素，然后再从该位置添加若干元素
			**concat() 方法用于连接两个或多个数组。此方法返回一个新数组，不改变原来的数组
			*join()方法用于把数组中的所有[元素]放入一个字符串[返回一个字符串] 元素是通过指定的分隔符进行分隔的[默认用逗号]
			
		  对象 
		    [ javascript中 所有数据类型都是对象,不过对象类型有所不同 ]
		    [ typeof检测对象类型][**null:object | array:object**]
			*遍历对象[for(var k in obj) K代表键  obj[k]代表值 ]
			*JavaScript的对象是一组由键-值组成的无序集合[键对应对象属性]
			*检查对象是否存在某个元素可以用in和hasOwnProperty()方法
			*JavaScript中数组|..都属于对象
			*对象中,访问属性是通过[.]操作符完成的 [特殊的属性必须用'[]'形式访问]
			*JavaScript的对象是动态类型，你可以自由地给一个对象添加或删除属性
			*Map[类]通过方法访问内部元素|支持非字符串的key 
			
			*尽量使用标准对象,尽量不要去用包装对象!!
			 可以选择parseInt() String() toString()方法嘛~~
			*创建对象 
			
		   面向对象的编程:
			 原型链的概念:所谓的继承不过是指向另一个原型
			 不建议用obj.__proto__去改变当前对象的原型对象
			 建议用object.create('object')去创建对象,参数为对象原型[注意:创建出的对象没有任何属性]
			 *用 关键字 NEW 调用函数时,此函数就会变成一个构造函数 它返回一个对象
			 
			 
			 
			 
		----------------------------------------------------------------------------	
		5.函数
			*事件与函数的结合
			*请严格遵守“在函数内部首先申明所有变量”这一规则[变量提升]
			*函数的作用域[不在任何函数内定义的变量就具有全局作用域]
				a.由内而外
				b.顶层函数的定义也被视为一个全局变量[函数也视为变量]，并绑定到window对象[javaScript默认全局对象]
				c.命名空间[防止命名冲突]
		----------------------------------------------------------------------------		
		6.事件[事件是可以被 JavaScript 侦测到的行为]
			[因为JavaScript在浏览器中以单线程模式运行，页面加载后，一旦页面上所有的JavaScript代码被执行完后，
			就只能依赖触发事件来执行JavaScript代码。]
			
			*on(事件名称,处理函数)方法用来绑定一个事件
			*绑定事件的简化写法
				
				[鼠标事件]
				click: 鼠标单击时触发；
				dblclick：鼠标双击时触发；
				mouseenter：鼠标进入时触发；
				mouseleave：鼠标移出时触发；
				mousemove：鼠标在DOM内部移动时触发；
				hover：鼠标进入和退出时触发两个函数，相当于mouseenter加上mouseleave。
				键盘事件

				键盘事件仅作用在当前焦点的DOM上，通常是<input>和<textarea>。
				keydown：键盘按下时触发；
				keyup：键盘松开时触发；
				keypress：按一次键后触发。
				其他事件

				focus：当DOM获得焦点时触发；
				blur：当DOM失去焦点时触发；
				change：当<input>、<select>或<textarea>的内容改变时触发；
				submit：当<form>提交时触发；
				ready：当页面被载入并且DOM树完成初始化后触发。
				
			*事件委托
				[当某个事件被触发后,时间构成的几个元素,会被打包成对象,记录下来,然后默认传到事件函数的第一个参数.[我们习惯用ev作为第一个参数,这个参数是隐藏的,我们可以打印]
				   [注意]ev.target就是指当前触发事件的'对象包',不用刻意去指明.]
			*取消绑定
				object.off(事件名称,处理函数)
			*浏览器限制
				有些事件必须要用户触发
				
				*鼠标单击[onClick]|经过[onmouseover]|移开[onmuseout]
				*文本框内容改变[onfocus]| 内容选中[onselect]|
				*光标聚焦|光标移开[onblur]
				*网页导入|关闭网页
				*加载网页 | 卸载事件
				*事件对象
				   当某个事件被触发后,时间构成的几个元素,会被打包成对象,记录下来,然后默认传到事件函数的第一个参数.[我们习惯用ev作为第一个参数,这个参数是隐藏的,我们可以打印]
				   [注意]ev.target就是指当前触发事件的'对象包',不用刻意去指明.
				*时间委托
				
		----------------------------------------------------------------------------
		7.JavaScript内置对象
			*日期对象 Date[D必须大写]
			*时间对象 set/getTime
				var now = new Date();
				now; // Wed Jun 24 2015 19:49:22 GMT+0800 (CST)
				now.getFullYear(); // 2015, 年份
				now.getMonth(); // 5, 月份，注意月份范围是0~11，5表示六月
				now.getDate(); // 24, 表示24号
				now.getDay(); // 3, 表示星期三
				now.getHours(); // 19, 24小时制
				now.getMinutes(); // 49, 分钟
				now.getSeconds(); // 22, 秒
				now.getMilliseconds(); // 875, 毫秒数
				now.getTime(); // 1435146562875, 以number形式表示的时间戳
			*charAt()返回指定的字符的位置,其实就是将字符串看成一个一维数组,也是醉了.
			*indexOf(substring,position)返回指定字符串首次出现的位置,否则返回 -1 
			*split() 方法将字符串分割为字符串[数组]，并返回此数组[如果把空字符串 ("") 用作 separator，那么 stringObject 中的每个字符之间都会被分割。]
			*substring() 方法用于提取字符串中介于两个指定下标之间的字符,最坏返回空字符串
			*substr() 方法从字符串中提取从 startPos位置开始到指定数目的字符串[用法参见limit]
			*Math[封装了很多数学函数] 对象是一个固有的对象，无需创建它，直接把 Math 作为对象使用就可以调用其所有属性和方法。这是它与Date,String对象的区别。
			 [注意]Math.random()返回的是[0,1)
			*slice()返回一个新的数组，包含从 start 到 end （不包括该元素）的 arrayObject 中的元素[一定要注意不包括末尾]
		----------------------------------------------------------------------------		
		8.浏览器(BOM)对象[默认为全局作用域]			
			*计时器[毫秒为单位]
			*setInterval(执行代码,交互时间) [间隔执行] [返回一个资源句柄]
			 调用函数 a.setInterval("function()",30)
			          b.setInterval(function,30)
			*clearInterval [根据返回的ID值,清除计时器]
			*setTimeout()计时器，在载入后延迟指定时间后,去执行一次表达式,仅执行一次。
			*history对象[网页记录列表]
			*location对象[获取URL | 设定URL ]
			*Navigator对象[浏览器版本分析]
			*screen对象[屏幕 | 窗口信息]
		----------------------------------------------------------------------------		
		9.DOM对象
			*document对象表示当前页面整个DOM树的根节点
			 a.遍历DOM可以选择渐进式的方式,也可以利用selector语法[都是对象方法].
			   getAttribute()方法通过元素节点的属性名称获取属性的值
			   setAttribute() 方法增加一个指定名称和值的新属性，或者把一个现有的属性设定为指定的值。
			   [childNodes] | [parentNode] | []
			 b.更新DOM 			   
			   innerHTML 不但可以改变HTML文本,而且可以改变树的结构(设置HTML标签),注意编码,避免[XSS攻击(1)]
			   innerText|textContent 自动编码无法设置html标签[两者区别(2)]
			   区别:innerText不返回隐藏元素的文本，而textContent返回所有文本
			 c.插入DOM
			   appendChild，把一个子节点添加到父节点的最后一个子节点.
			   如果是转移节点,会先删除,然后插入,[但是]更多的时候我们会从零创建一个新的节点(createElement)，然后插入到指定位置
			   insertBefore(要插入的节点,refrenceNode)
			 d.删除DOM[先找到父节点]
			   removeChild[child结点索引会发生改变]
			   node.replaceChild (newnode,oldnew ) 
			   *删除节点后,结点依然保存在内存中
			 e.表单操作[表单也是对象]
			   a.获取表单值 #id.value
			     怎么获取复选框的值? #id.checkd 返回布尔值
			   b.设置表单值 #id.value = "xxx"[更新]
			   c.提交表单 form的 [onsubmit]方法,实质上是一个截断|回调函数,他会中途拦截表单提交,判断|修改,选择继续提交还是终止提交表单.
			   
			 f.文件操作
			   *文件扩展名判断
			   [例
				var f = document.getElementById('test-file-upload');
				var filename = f.value; // 'C:\fakepath\test.png'
				if (!filename || !(filename.endsWith('.jpg') || filename.endsWith('.png') || filename.endsWith('.gif'))) {
					alert('Can only upload image file.');
					return false;
				}
			   ]
			   *
			   ----------------------------------------------------------------------------
			10.面向对象编程
			   Everything is Object in JavaScript.
			   *JavaScript不区分类和实例的概念，而是通过原型（prototype）来实现面向对象编程
			   [例
					var Student = {
					name: 'Robot',
					height: 1.2,
					run: function () {
						console.log(this.name + ' is running...');
					}
				};
					var xiaoming = {
						name: '小明'
					};

				xiaoming.__proto__ = Student;  [注:通过指向原型,类似继承效果]
				xiaoming.__proto__ = Bird;     [注:原型对象可以随时改变]
				但是一般来说,我们习惯采用Object.create()方法传入一个对象,并基于此,创建一个新对象.
			   ]
			
			
			
			
	*/	
	 /* ===============================================  AJAx   ==================================================================== */	
	
	
	/*
	预备知识
		*
		*
		*JavaScript

	
	学习路线:
		*同步与异步
		*HTTP请求
		 一个完整的HTTP请求通常包含以下7个步骤
		 1.TCP链接
		 2.B->S命令
		 3.B->请求头信息
		 4.S->响应
		 5.S->响应头信息
		 6.S->数据传输
		 7.S->关闭TCP连接
		 
		 HTTP状态码
		 1xx 信息连接
		 2xx 执行状态
		 3xx 重定向 客户端需要继续请求
		 4xx 客户端错误
		 5xx 服务器错误
		 
		*XML HTTP Request对象创建 
		*XML HTTP Request发送请求
		*XML HTTP Request响应
			responseText
			responseXML-----childNotes和child有什么区别
			
		*readyState (
			0 => 请求还未初始化 open还未调用
			1 => 调用open
			2 => 接收头信息
			3 => 接收主体信息
			4 => 响应完成
		)
		
		*POST类型 需要加一句xmlhttp.setRequestHeader("Content-type","application/x-www-form-urlencoded");
		*建立多个ajax任务 使用回调函数
			
		var request = XMLhttpRequest();
		request.open('post','get.php',true);//调用请求
		request.setRequestHeader("Content-type","application/x-www-form-urlencoded");//如果采用post请求并传递参数,一定要加上头信息
		
		request.send();//发送清请求
		request.onreadystatechange = function(){
			if(request.status === 200 && request.readystate === 4){
				request.responseText;
			}
		}		
		
		*Ajax + PHP 
		
		*JSON
			JavaScript的对象表示法 存储与交换文本信息的语法,独立于其他语言  键值对
		*JQuery
		
		*跨域
			一是通过Flash插件发送HTTP请求
			二是架设一个代理服务器
			三是JSONP[回调函数]
	*/	
		
		
		
	/* ===============================================  JQuery   ==================================================================== */		
		[绑定事件的哪些个写法]
		1.$('#selector').on('click',function(){
			
		});
		2.$('#selector').click(function(){
			
		});
		3.$('#selector').onclick = function(){
			
		};
		
		[ready]
		1.$(document).ready(function(){
			
		});
		2.$(function(){
			
		});
		[事件API 查手册[change ready],不用强记]
	/*
		学习路线:
			1.环境搭建
				使用jQuery只需要在页面的<head>引入jQuery文件即可：
				<src = "https://code.jquery.com/jquery-3.1.1.min.js" >
			1.样式
				*JQuery对象
				*对象转换,混合JavaScript原生代码
					JQuery->Dom  a.数组下标,返回元素  b.get()方法
					例子:
					a.var $div = $('div') //jQuery对象
					  var div = $div[0] //转化成DOM对象
					b.var $div = $('div') //jQuery对象
					  var div = $div.get(0) //通过get方法，转化成DOM对象
					Dom->JQuery [其实开发中,我们更多的是将DOM对象转换为JQuery对象]
					   [得到一个DOM对象div,只需要用$()将其包装起来,赋值给$div,此时,$div就是一个JQuery对象.]
					
				选择器[选择器是jQuery的核心]	[返回的是对象][若访问的对象不存在则返回 '[]']
					*$("#id")    |ID查找
					*$(".class") |隐式循环
					*$("element")|tag选择 $("div") $("p")
					*$('[name = email ]')属性选择 找出<??? name = "password" >
					 按属性的前后缀查找
					 var icons = $('[name^=icon]'); // 找出所有name属性值以icon开头的DOM
					 var names = $('[name$=with]'); // 找出所有name属性值以with结尾的DOM
					*组合选择 利用[,]组合 
					*层级选择器
					*特殊选择器 [this 可以调用html对象所拥有的属性和方法。] 一般会将this加工成$this [$this 可以调用jQuery的方法和属性值]
						[
							this，表示当前的上下文对象是一个html对象，可以调用html对象所拥有的[属性]和[方法]。
							$(this),代表的上下文对象是一个jquery的上下文对象，可以调用jQuery的[方法]和[属性值]。
						]					
					*筛选选择器
						nth-child(n) 索引从1开始
						eq(index)    索引从0开始
					*查找与过滤[对象的方法]
					 find[由上而下]
					 parent[由内而外]
					 filter[过滤掉不符合条件的结点]
				属性与样式
					[批量操作]
					[链式调用]
					.attr 
						a.attr(传入属性名)：获取属性的值
						b.attr(属性名, 属性值)：设置属性的值
					.removeAttr
					.html [针对整个HTML内容（不仅仅只是文本内容）]
						a.html()获取第一个匹配[元素]html内容
						b.html( htmlString )  设置每一个匹配元素的html内容
						c.html( function(index, oldhtml) ) 用来返回设置HTML内容的一个函数
					.text [结果返回一个字符串，包含所有匹配元素的[合并文本]]
					
					JQuery提供show()和hide()方法,用于修改display属性
					
					操作表单  [对于表单元素，jQuery对象统一提供[val()]方法获取和设置对应的value属性]
					 同样的,
					 .val() 获取value值
					 .val('xxx') 设置val值
				事件[JavaScript单线程模式]
					*事件绑定:
					on方法用来绑定一个事件，我们需要传入事件名称和对应的处理函数
					[例
						a.on('click', function () {
						alert('Hello!');
						});
						
					 或	a.click(function () {
						alert('Hello!');
						});					
					]
					*取消绑定
					 通过off('click', function)
					
					*鼠标事件
					click: 鼠标单击时触发；
					dblclick：鼠标双击时触发；
					mouseenter：鼠标进入时触发；
					mouseleave：鼠标移出时触发；
					mousemove：鼠标在DOM内部移动时触发；
					hover：鼠标进入和退出时触发两个函数，相当于mouseenter加上mouseleave。
					
					键盘事件
					键盘事件仅作用在当前焦点的DOM上，通常是<input>和<textarea>。
					keydown：键盘按下时触发；
					keyup：键盘松开时触发；
					keypress：按一次键后触发。
					
					其他事件
					focus：当DOM获得焦点时触发；
					blur：当DOM失去焦点时触发；
					change：当<input>、<select>或<textarea>的内容改变时触发；
					submit：当<form>提交时触发；
					ready：当页面被载入并且DOM树完成初始化后触发[ready事件在DOM完成初始化后触发，且只触发一次，所以非常适合用来写其他的初始化代码]
					[例 这是ready事件函数的简写形式
						$(function () {
						// init...
						});
					]
	*/	
			[注意事件的加载是有顺序的,我们需要了解一下浏览器渲染的过程]
	/* ===============================================  JQuery Moblie   ==================================================================== */	
		/*	http://www.corsproxy.com/	*/
	列表: 			  
		  data-role = "listview"[列表项会自动转换为按钮]
		  圆角|外边距 data-inset = "true"
		  列表分隔符  data-autodividers = "true" [属性通过对列表项文本的首字母进行大写来创建分隔符。]
		  搜索        data-filter = "true"
		  搜索框文本  data-filter-placeholder="搜索姓名"
		  	
	表单:
		文本框[搜索框][单选][多选框][切换开关][滑动条]
		data-role = "fieldcontain"[屏幕自适应]
		placeholder[文本框提示]
		
		 
	表格:[reflow(回流) |columntoggle (列切换)]
		data-position="fixed"[固定边栏]
		[reflow:
		  <table data-role = "table" data-role = "reflow" class = "ui-responsive table-stroke">
			<thead>
				<tr>
				</tr>
			</thead>
			<tbody>
				<td>
				</td>
			</tbody>
		  </table>
		-------------------------------------------------------------------  
		]
		[列切换:列切换模型会在宽度不够时隐藏数据
			
		]
	


	/*			COde							*/
	100：继续  客户端应当继续发送请求。客户端应当继续发送请求的剩余部分，或者如果请求已经完成，忽略这个响应。

    101： 转换协议  在发送完这个响应最后的空行后，服务器将会切换到在Upgrade 消息头中定义的那些协议。只有在切换新的协议更有好处的时候才应该采取类似措施。

    102：继续处理   由WebDAV（RFC 2518）扩展的状态码，代表处理将被继续执行。

    200：请求成功      处理方式：获得响应的内容，进行处理

    201：请求完成，结果是创建了新资源。新创建资源的URI可在响应的实体中得到    处理方式：爬虫中不会遇到

    202：请求被接受，但处理尚未完成    处理方式：阻塞等待

    204：服务器端已经实现了请求，但是没有返回新的信 息。如果客户是用户代理，则无须为此更新自身的文档视图。    处理方式：丢弃

    300：该状态码不被HTTP/1.0的应用程序直接使用， 只是作为3XX类型回应的默认解释。存在多个可用的被请求资源。    处理方式：若程序中能够处理，则进行进一步处理，如果程序中不能处理，则丢弃
    301：请求到的资源都会分配一个永久的URL，这样就可以在将来通过该URL来访问此资源    处理方式：重定向到分配的URL

    302：请求到的资源在一个不同的URL处临时保存     处理方式：重定向到临时的URL

    304：请求的资源未更新     处理方式：丢弃

    400：非法请求     处理方式：丢弃

    401：未授权     处理方式：丢弃

    403：禁止     处理方式：丢弃

    404：没有找到     处理方式：丢弃

    500：服务器内部错误  服务器遇到了一个未曾预料的状况，导致了它无法完成对请求的处理。一般来说，这个问题都会在服务器端的源代码出现错误时出现。

    501：服务器无法识别  服务器不支持当前请求所需要的某个功能。当服务器无法识别请求的方法，并且无法支持其对任何资源的请求。

    502：错误网关  作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到无效的响应。

    503：服务出错   由于临时的服务器维护或者过载，服务器当前无法处理请求。这个状况是临时的，并且将在一段时间以后恢复。
   
   
   
/***************************************  Node.js  **************************************************/
	1.JavaScript是单线程执行，根本不能进行同步IO操作	
    2.勾选Add to Path这个选项，自动配置环境变量
    3.在不同的模块中，可以出现相同的函数名和变量名
	4.module.exports 暴露模块
	[注意：文件写入会覆盖之前的文件？]
	
	
	

  
/***************************************  laravel  **************************************************/

	数据库（2017-8-2）
	DB->select以及 table方法 返回的结果是stdClass对象
	参数绑定是为了避免SQL注入，参见PDO




     关于使用模型工厂[ModelFactory] + 填充类[DatabaseSeeder] 填充数据到数据库
	 
	 1.建立迁移任务
       php artisan make:migration create_users_table	
	 2.编写Up\Down的业务逻辑  
	 3.执行迁移任务
	   php artisan migrate #要指定文件跑（migrate会跑整个文件夹） 如：php artisan migrate --path=/database/migrations/ourself

	（1-3 主要是建立表模型 和白名单字段）


	 4.建立表对应的模型
	   php artisan make:model User
	 5.定义模型工厂的业务逻辑


	 6.建立填充类（类名称最好和你的表名称相关）
	   php artisan make:seeder UsersTableSeeder
	 7.编写run方法业务逻辑
	 8.DatabaseSeeder.php 调用自定义填充类(call方法)

     9.执行填充类	   
       php artisan db:seed
  
    
	坑：
	   =号之间不能有空格
	   模型对应的表名是模型的复数形式，不是加个S就好了
       模型方法(create)之前必须要设置白名单
  
  
  /***************************************  Java  **************************************************/

  一、遵守基本规则：
  	1.文件名与类名一致
  	2.类名首字母大写，方法名首字母小写
  	3.大小写敏感
  	4.main方法为程序的执行入口

  二、基本数据类型：
  	内置数据类型：
  		byte	
  		short
  		int
  		long
  		float
  		double

  		boolean
  		char

  		void

  三、变量类型
  	1.类变量
  	  属性：静态变量（多用于声明常量）
  	  生命周期：静态变量在程序开始时创建，在程序结束时销毁
  	  可见性：  一般为public
  	  访问方式：ClassNAme.VariableName

  	2.实例变量
  	  属性：动态 有默认值
  	  声明周期：对象开始时创建，对象结束时销毁
  	  可见性：访问控制
  	  访问方式：  
  	  	a.直接通过变量名访问
  	  	b.在静态方法或其他类中应该使用完全限定名

  	3.局部变量
  		属性：动态 没有默认值
  		生命周期：语句开始时创建，执行完毕后销毁
  		可见性：不能用访问控制（全可见）
  		访问方式：直接访问

注：
	静态变量与实例变量的区别：
		




  java源程序和编译型程序的运行区别：

   
     
   




































